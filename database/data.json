[
    {
      "test": "Системою числення називається",
      "variant_1": [
        "сукупність правил виконання операцій над натуральними числами",
        "False"
      ],
      "variant_2": [
        "вага кожної позиції числа, що кратна деякому натуральному числу",
        "False"
      ],
      "variant_3": [
        " сукупність правил і знаків, за допомогою яких можна відобразити будь-яке невід'ємне число",
        "True"
      ]
    },
    {
      "test": "Програмний код (текст програми) на мові високого рівня створюється за допомогою:",
      "variant_1": [
        "транслятора",
        "False"
      ],
      "variant_2": [
        " текстового редактора",
        "True"
      ],
      "variant_3": [
        "компілятора",
        "False"
      ]
    },
    {
      "test": "Компонувальник комп’ютерної програми",
      "variant_1": [
        "визначає помилки, пов’язані з порушенням правил граматики в програмному коді",
        "False"
      ],
      "variant_2": [
        "перетворює програмний код в об'єктний",
        "False"
      ],
      "variant_3": [
        " формує повний код програми у вигляді готового до виконання файлу",
        "True"
      ]
    },
    {
      "test": "Інтерпретатор комп’ютерної програми",
      "variant_1": [
        "формує повний код програми у вигляді готового до виконання файлу",
        "False"
      ],
      "variant_2": [
        " здійснює послідовну обробку кожного оператора (команди), перетворення його в машинний код та виконання",
        "True"
      ],
      "variant_3": [
        "перетворює програмний код в об'єктний",
        "False"
      ]
    },
    {
      "test": "Помилки, пов’язані з порушенням правил граматики в тексті програми, написаної мовою високого рівня, називаються",
      "variant_1": [
        " помилками часу трансляції",
        "True"
      ],
      "variant_2": [
        "помилками часу виконання",
        "False"
      ],
      "variant_3": [
        "семантичними",
        "False"
      ]
    },
    {
      "test": "Налагодження програмного коду – це",
      "variant_1": [
        "процес виявлення в ньому помилок часу трансляції",
        "False"
      ],
      "variant_2": [
        "процес перетворення програмного коду в об'єктний",
        "False"
      ],
      "variant_3": [
        " процес багаторазового виконання коду з різними варіантами даних для виявлення помилок всіх типів",
        "True"
      ]
    },
    {
      "test": "Мова програмування – це",
      "variant_1": [
        "сукупність команд, що використовується конкретним комп’ютером для розв’язання задач",
        "False"
      ],
      "variant_2": [
        "алгоритми розв’язання задач на комп’ютері",
        "False"
      ],
      "variant_3": [
        " правила подання даних і запису алгоритмів їх обробки, що автоматично виконуються комп’ютером",
        "True"
      ]
    },
    {
      "test": "(C++) В ідентифікаторах програмних об’єктів можна використовувати",
      "variant_1": [
        " латинські букви та цифри",
        "True"
      ],
      "variant_2": [
        "пробіли",
        "False"
      ],
      "variant_3": [
        "кириличні букви та цифри",
        "False"
      ]
    },
    {
      "test": "Лексема в мові програмуванні – це",
      "variant_1": [
        "зарезервований ідентифікатор, що має спеціальне значення для компілятора",
        "False"
      ],
      "variant_2": [
        " мінімальна одиниця програмного коду, що має самостійний зміст",
        "True"
      ],
      "variant_3": [
        "рядок символів, що ігнорується компілятором",
        "False"
      ]
    },
    {
      "test": "Ключове слово в мові програмуванні – це",
      "variant_1": [
        " зарезервований ідентифікатор, що має спеціальне значення для компілятора",
        "True"
      ],
      "variant_2": [
        "мінімальна одиниця програмного коду, що має самостійний зміст",
        "False"
      ],
      "variant_3": [
        "набір символів, які визначають дію над операндами",
        "False"
      ]
    },
    {
      "test": "(C++) Блоком програмного коду вважається послідовність операторів, обмежена",
      "variant_1": [
        " фігурними дужками { }",
        "True"
      ],
      "variant_2": [
        "круглими дужками ()",
        "False"
      ],
      "variant_3": [
        "ключовими словами begin … end",
        "False"
      ]
    },
    {
      "test": "(C++) Escape-послідовність – це рядок, що починається з символу",
      "variant_1": [
        "/",
        "False"
      ],
      "variant_2": [
        " \\",
        "True"
      ],
      "variant_3": [
        "&",
        "False"
      ]
    },
    {
      "test": "(C++) Знак операції – це",
      "variant_1": [
        "символ,  що визначає послідовність виконання операцій",
        "False"
      ],
      "variant_2": [
        "символ =",
        "False"
      ],
      "variant_3": [
        " один або більше символів, які визначають дію над операндами",
        "True"
      ]
    },
    {
      "test": "(C++) Коментар – це текст, що",
      "variant_1": [
        " починається з лексеми // і завершується кінцем рядку",
        "True"
      ],
      "variant_2": [
        "зазначається в фігурних дужках",
        "False"
      ],
      "variant_3": [
        " розташований між лексемами /* і */",
        "True"
      ]
    },
    {
      "test": "(C++) Прості типи даних – це",
      "variant_1": [
        "рядки",
        "False"
      ],
      "variant_2": [
        " цілі, дійсні числа",
        "True"
      ],
      "variant_3": [
        " тип void",
        "True"
      ]
    },
    {
      "test": "(C++) Складені типи даних – це",
      "variant_1": [
        "символи",
        "False"
      ],
      "variant_2": [
        " масиви",
        "True"
      ],
      "variant_3": [
        " рядки",
        "True"
      ]
    },
    {
      "test": "(C++) До цілих типів даних належать",
      "variant_1": [
        " char",
        "True"
      ],
      "variant_2": [
        " long",
        "True"
      ],
      "variant_3": [
        "float",
        "False"
      ]
    },
    {
      "test": "(C++) До дійсних типів даних належать",
      "variant_1": [
        "long",
        "False"
      ],
      "variant_2": [
        " double",
        "True"
      ],
      "variant_3": [
        "real",
        "False"
      ]
    },
    {
      "test": "(C++) Логічний тип даних позначається ключовим словом",
      "variant_1": [
        "log",
        "False"
      ],
      "variant_2": [
        "boolean",
        "False"
      ],
      "variant_3": [
        " bool",
        "True"
      ]
    },
    {
      "test": "(C++) Перелічуваний тип даних позначається ключовим словом",
      "variant_1": [
        " enum",
        "True"
      ],
      "variant_2": [
        "array",
        "False"
      ],
      "variant_3": [
        "struct",
        "False"
      ]
    },
    {
      "test": "(C++) Директиви процесора – це команди, які виконуються",
      "variant_1": [
        "під час виконання програми",
        "False"
      ],
      "variant_2": [
        " на початку компіляції програми",
        "True"
      ],
      "variant_3": [
        "в процесі тестування програми",
        "False"
      ]
    },
    {
      "test": "(C++) Директиви процесора починаються з символу",
      "variant_1": [
        "&",
        "False"
      ],
      "variant_2": [
        "@",
        "False"
      ],
      "variant_3": [
        " #",
        "True"
      ]
    },
    {
      "test": "(C++) Змінна – це",
      "variant_1": [
        " іменована область пам'яті, в якій зберігаються дані певного типу",
        "True"
      ],
      "variant_2": [
        "ключове слово, що визначає тип даних",
        "False"
      ],
      "variant_3": [
        "оператор, який виконує обчислення",
        "False"
      ]
    },
    {
      "test": "(C++) Ініціалізація змінної – це",
      "variant_1": [
        " присвоєння початкового значення",
        "True"
      ],
      "variant_2": [
        "надання змінній імені (присвоєння ідентифікатора)",
        "False"
      ],
      "variant_3": [
        "визначення типу змінної",
        "False"
      ]
    },
    {
      "test": "(C++) Область дії ідентифікатора – це",
      "variant_1": [
        " частина програми, в якій його можна використовувати для доступу до пов'язаної з ним області пам'яті",
        "True"
      ],
      "variant_2": [
        "рядок програми, в якому він оголошений",
        "False"
      ],
      "variant_3": [
        "всі рядки програми, де він використовується",
        "False"
      ]
    },
    {
      "test": "(C++) Змінна, визначена всередині блоку програмного коду, називається",
      "variant_1": [
        "глобальною",
        "False"
      ],
      "variant_2": [
        " локальною",
        "True"
      ],
      "variant_3": [
        "тимчасовою",
        "False"
      ]
    },
    {
      "test": "(C++) Областю дії глобальної змінної є",
      "variant_1": [
        "весь файл, в якому вона визначена",
        "False"
      ],
      "variant_2": [
        "блок, в якому вона визначена",
        "False"
      ],
      "variant_3": [
        " файл, в якому вона визначена, від точки опису до його кінця",
        "True"
      ]
    },
    {
      "test": "(C++) Для заокруглення значення змінної а до найменшого цілого, але не меншого, ніж a, можна використати функцію",
      "variant_1": [
        "abs(a)",
        "False"
      ],
      "variant_2": [
        "floor(a)",
        "False"
      ],
      "variant_3": [
        " ceil(a)",
        "True"
      ]
    },
    {
      "test": "(C++) Для заокруглення значення змінної а до найбільшого цілого, але не більшого, ніж a,  можна використати функцію",
      "variant_1": [
        " floor(a)",
        "True"
      ],
      "variant_2": [
        "ceil(a)",
        "False"
      ],
      "variant_3": [
        "abs(a)",
        "False"
      ]
    },
    {
      "test": "(C++) Команди потокового введення-виведення описані в модулі",
      "variant_1": [
        " iostream.h (iostream)",
        "True"
      ],
      "variant_2": [
        "conio.h",
        "False"
      ],
      "variant_3": [
        "stdio.h",
        "False"
      ]
    },
    {
      "test": "(C++) Команда виведення даних на екран монітору має вигляд",
      "variant_1": [
        "cin >>",
        "False"
      ],
      "variant_2": [
        "cout >>",
        "False"
      ],
      "variant_3": [
        " cout <<",
        "True"
      ]
    },
    {
      "test": "(C++) Команда введення даних з клавіатури має вигляд",
      "variant_1": [
        " cin >>",
        "True"
      ],
      "variant_2": [
        "cin <<",
        "False"
      ],
      "variant_3": [
        "cout <<",
        "False"
      ]
    },
    {
      "test": "(C++) Префіксна форма запису операції інкременту виглядає так:",
      "variant_1": [
        " ++x",
        "True"
      ],
      "variant_2": [
        "**x",
        "False"
      ],
      "variant_3": [
        "&&x",
        "False"
      ]
    },
    {
      "test": "(C++) До унарних арифметичних операцій належать:",
      "variant_1": [
        "ділення (/)",
        "False"
      ],
      "variant_2": [
        " інкремент (++)",
        "True"
      ],
      "variant_3": [
        "залишок від ділення (%)",
        "False"
      ]
    },
    {
      "test": "(C++) До бінарних арифметичних операцій належать:",
      "variant_1": [
        "декремент (--)",
        "False"
      ],
      "variant_2": [
        "арифметичне заперечення (-)",
        "False"
      ],
      "variant_3": [
        " залишок від ділення (%)",
        "True"
      ]
    },
    {
      "test": "(C++) Операціями присвоювання, суміщеними з іншими операціями, є",
      "variant_1": [
        " +=",
        "True"
      ],
      "variant_2": [
        "=+",
        "False"
      ],
      "variant_3": [
        "&&",
        "False"
      ]
    },
    {
      "test": "(C++) До унарних логічних операцій належать:",
      "variant_1": [
        " !",
        "True"
      ],
      "variant_2": [
        "?",
        "False"
      ],
      "variant_3": [
        "&",
        "False"
      ]
    },
    {
      "test": "(C++) Результат операції && дорівнює",
      "variant_1": [
        "true, якщо хоча б один з операндів дорівнює true",
        "False"
      ],
      "variant_2": [
        " true, лише тоді, коли обидва операнди дорівнюють true",
        "True"
      ],
      "variant_3": [
        "false, лише тоді, коли обидва операнди дорівнюють false",
        "False"
      ]
    },
    {
      "test": "(C++) Результат операції || дорівнює",
      "variant_1": [
        " false, лише тоді, коли обидва операнди дорівнюють false",
        "True"
      ],
      "variant_2": [
        "true, лише тоді, коли обидва операнди дорівнюють true",
        "False"
      ],
      "variant_3": [
        " true, якщо хоча б один з операндів дорівнює true",
        "True"
      ]
    },
    {
      "test": "(C++) Перевірка двох цілих значень на рівність виконується оператором",
      "variant_1": [
        "<>",
        "False"
      ],
      "variant_2": [
        " ==",
        "True"
      ],
      "variant_3": [
        "?=",
        "False"
      ]
    },
    {
      "test": "(C++) Операції зсуву вліво позначаються лексемою",
      "variant_1": [
        " <<",
        "True"
      ],
      "variant_2": [
        "<=",
        "False"
      ],
      "variant_3": [
        "<-",
        "False"
      ]
    },
    {
      "test": "(C++) Виконання операторів тіла циклу називається",
      "variant_1": [
        " ітерацією",
        "True"
      ],
      "variant_2": [
        "операцією",
        "False"
      ],
      "variant_3": [
        "варіацією",
        "False"
      ]
    },
    {
      "test": "У мові С++ є такі різновиди операторів циклу",
      "variant_1": [
        " з постумовою",
        "True"
      ],
      "variant_2": [
        "з селектором",
        "False"
      ],
      "variant_3": [
        " з лічильником",
        "True"
      ]
    },
    {
      "test": "(C++) while <умова> <оператор> є циклом",
      "variant_1": [
        "з лічильником",
        "False"
      ],
      "variant_2": [
        " з передумовою",
        "True"
      ],
      "variant_3": [
        "з постумовою",
        "False"
      ]
    },
    {
      "test": "(C++) Тіло циклу виконується завжди хоча б один раз в операторі циклу",
      "variant_1": [
        "з лічильником",
        "False"
      ],
      "variant_2": [
        "з передумовою",
        "False"
      ],
      "variant_3": [
        " з постумовою",
        "True"
      ]
    },
    {
      "test": "(C++) У цикл з передумовою або постумовою для запобігання зациклення потрібно",
      "variant_1": [
        " змінювати значення змінної в умові виходу в тілі циклу",
        "True"
      ],
      "variant_2": [
        "не змінювати значення змінної в умові виходу в тілі циклу",
        "False"
      ],
      "variant_3": [
        "застосовувати оператор continue",
        "False"
      ]
    },
    {
      "test": "(C++) Для примусового переривання циклу в його тіло слід включити оператор",
      "variant_1": [
        "exit",
        "False"
      ],
      "variant_2": [
        "continue",
        "False"
      ],
      "variant_3": [
        " break",
        "True"
      ]
    },
    {
      "test": "(C++) Пропуск усіх команд у тілі циклу і перехід до наступної ітерації, здійснюється після оператора",
      "variant_1": [
        "repeat",
        "False"
      ],
      "variant_2": [
        " continue",
        "True"
      ],
      "variant_3": [
        "break",
        "False"
      ]
    },
    {
      "test": "(C++) Заголовок функції починається з ключового слова void",
      "variant_1": [
        "для функцій, що повертають значення",
        "False"
      ],
      "variant_2": [
        " для функцій, що не повертають значення",
        "True"
      ],
      "variant_3": [
        "для функцій, що не мають параметрів",
        "False"
      ]
    },
    {
      "test": "(C++) Ключове слово return використовується в тілі функцій,",
      "variant_1": [
        "які не повертають значення",
        "False"
      ],
      "variant_2": [
        "які повертають тільки цілі значення",
        "False"
      ],
      "variant_3": [
        " які повертають значення будь-яких типів крім void",
        "True"
      ]
    },
    {
      "test": "(C++) Після імені функції ставляться круглі дужки",
      "variant_1": [
        " завжди",
        "True"
      ],
      "variant_2": [
        "ніколи",
        "False"
      ],
      "variant_3": [
        "тільки при наявності аргументів",
        "False"
      ]
    },
    {
      "test": "(C++) Аргументи функцій",
      "variant_1": [
        " зазначаються в круглих дужках після імені функції",
        "True"
      ],
      "variant_2": [
        " відокремлюються один від одного комою",
        "True"
      ],
      "variant_3": [
        "відокремлюються один від одного крапкою з комою",
        "False"
      ]
    },
    {
      "test": "(C++) Тіло функції – це послідовність команд виконання алгоритму, розташована після заголовку функції",
      "variant_1": [
        "в круглих дужках",
        "False"
      ],
      "variant_2": [
        " в фігурних дужках",
        "True"
      ],
      "variant_3": [
        "між ключовими словами begin і end",
        "False"
      ]
    },
    {
      "test": "(C++) Значення, що повертається функцією, зазначається після ключового слова",
      "variant_1": [
        "extern",
        "False"
      ],
      "variant_2": [
        "export",
        "False"
      ],
      "variant_3": [
        " return",
        "True"
      ]
    },
    {
      "test": "У мові С++ одне і те саме ім’я функції",
      "variant_1": [
        " допускається використовувати для різних наборів аргументів",
        "True"
      ],
      "variant_2": [
        "допускається використовувати для однакових наборів аргументів",
        "False"
      ],
      "variant_3": [
        "забороняється використовувати",
        "False"
      ]
    },
    {
      "test": "(C++) Якщо глобальній і локальній змінній присвоїти однакове ім’я, то",
      "variant_1": [
        " глобальна змінна в області дії локальної змінної буде невидимою",
        "True"
      ],
      "variant_2": [
        "локальна змінна в області дії глобальної змінної буде невидимою",
        "False"
      ],
      "variant_3": [
        "компілятор виявить помилку",
        "False"
      ]
    },
    {
      "test": "(C++) Отримати доступ до глобальної змінної в області видимості локальної змінної",
      "variant_1": [
        "не можливо",
        "False"
      ],
      "variant_2": [
        " можна за допомогою оператора «::»",
        "True"
      ],
      "variant_3": [
        "можна за допомогою оператора «@»",
        "False"
      ]
    },
    {
      "test": "(C++) Параметри, імена яких вказані в заголовку функції, називаються",
      "variant_1": [
        "локальними",
        "False"
      ],
      "variant_2": [
        "фактичними",
        "False"
      ],
      "variant_3": [
        " формальними",
        "True"
      ]
    },
    {
      "test": "(C++) Параметри, значення яких передаються функції під час її виклику, називаються",
      "variant_1": [
        " фактичними",
        "True"
      ],
      "variant_2": [
        "формальними",
        "False"
      ],
      "variant_3": [
        "глобальними",
        "False"
      ]
    },
    {
      "test": "(C++) Зміна параметрів-значень усередині функції",
      "variant_1": [
        "заборонена",
        "False"
      ],
      "variant_2": [
        "впливає на значення її аргументів, переданих під час виклику",
        "False"
      ],
      "variant_3": [
        " не впливає на значення її аргументи, переданих під час виклику",
        "True"
      ]
    },
    {
      "test": "(C++) В разі потреби змінювати значення аргументів функції за її межами, необхідно в її заголовку застосовувати",
      "variant_1": [
        " параметри-покажчики",
        "True"
      ],
      "variant_2": [
        " параметри-посилання",
        "True"
      ],
      "variant_3": [
        "параметри-значення",
        "False"
      ]
    },
    {
      "test": "(C++) До посилальних типів даних належать",
      "variant_1": [
        " покажчики",
        "True"
      ],
      "variant_2": [
        " посилання",
        "True"
      ],
      "variant_3": [
        "змінні перелічувального типу",
        "False"
      ]
    },
    {
      "test": "(C++) Покажчики",
      "variant_1": [
        "містять альтернативні імена змінних",
        "False"
      ],
      "variant_2": [
        " дозволяють працювати з адресами комірок оперативної пам'яті",
        "True"
      ],
      "variant_3": [
        " реалізують непрямий доступ до вмісту комірок оперативної пам'яті",
        "True"
      ]
    },
    {
      "test": "(C++) Посилання є",
      "variant_1": [
        " є альтернативним іменем змінної",
        "True"
      ],
      "variant_2": [
        "значенням змінної",
        "False"
      ],
      "variant_3": [
        "адресою змінної в оперативній пам'яті",
        "False"
      ]
    },
    {
      "test": "(C++) Операцією отримання адреси є",
      "variant_1": [
        "$",
        "False"
      ],
      "variant_2": [
        " &",
        "True"
      ],
      "variant_3": [
        "@",
        "False"
      ]
    },
    {
      "test": "(C++) Покажчик, що не адресує жодну змінну, може дорівнювати",
      "variant_1": [
        "nil",
        "False"
      ],
      "variant_2": [
        " 0",
        "True"
      ],
      "variant_3": [
        " NULL",
        "True"
      ]
    },
    {
      "test": "(C++) В оголошенні покажчика синтаксисом передбачений символ",
      "variant_1": [
        " *",
        "True"
      ],
      "variant_2": [
        "^",
        "False"
      ],
      "variant_3": [
        "&",
        "False"
      ]
    },
    {
      "test": "(C++) В оголошенні посилання синтаксисом передбачений символ",
      "variant_1": [
        "^",
        "False"
      ],
      "variant_2": [
        " &",
        "True"
      ],
      "variant_3": [
        "*",
        "False"
      ]
    },
    {
      "test": "(C++) Над покажчиками можна виконувати такі арифметичні операції:",
      "variant_1": [
        "додавання до покажчиків дійсних чисел",
        "False"
      ],
      "variant_2": [
        " віднімання від покажчиків цілих чисел",
        "True"
      ],
      "variant_3": [
        " інкремент і декремент",
        "True"
      ]
    },
    {
      "test": "(C++) Операція розмінування покажчика визначає",
      "variant_1": [
        " значення змінної за її адресою",
        "True"
      ],
      "variant_2": [
        "адресу змінної",
        "False"
      ],
      "variant_3": [
        "псевдонім змінної",
        "False"
      ]
    },
    {
      "test": "(C++) До функції можна застосувати такі операції:",
      "variant_1": [
        " отримання адреси функції (покажчика)",
        "True"
      ],
      "variant_2": [
        "опис функції",
        "False"
      ],
      "variant_3": [
        " виклик функції",
        "True"
      ]
    },
    {
      "test": "(C++) Оголошення покажчика на функцію та заголовки функцій, на які посилатиметься цей покажчик,",
      "variant_1": [
        " повинні бути узгоджені за типами параметрів",
        "True"
      ],
      "variant_2": [
        " повинні бути узгоджені за значеннями, що повертаються",
        "True"
      ],
      "variant_3": [
        "можуть містити різний склад параметрів",
        "False"
      ]
    },
    {
      "test": "(C++) Операції new і delete застосовуються",
      "variant_1": [
        "до покажчиків будь-яких типів",
        "False"
      ],
      "variant_2": [
        " до покажчиків будь-яких типів, крім void*",
        "True"
      ],
      "variant_3": [
        "тільки для покажчиків типу void*",
        "False"
      ]
    },
    {
      "test": "(C++) Способами створення складних структур даних є:",
      "variant_1": [
        " об’єднання однорідних даних  у масиви",
        "True"
      ],
      "variant_2": [
        "об’єднання різнорідних даних  у масиви",
        "False"
      ],
      "variant_3": [
        " об’єднання різнорідних елементів у структури типу struct",
        "True"
      ]
    },
    {
      "test": "(C++) Одновимірний масив – це",
      "variant_1": [
        "сукупність даних різних типів",
        "False"
      ],
      "variant_2": [
        "множина цілих чисел",
        "False"
      ],
      "variant_3": [
        " послідовність однотипних даних",
        "True"
      ]
    },
    {
      "test": "(C++) Тип елементів масиву називається",
      "variant_1": [
        " базовим",
        "True"
      ],
      "variant_2": [
        "індексним",
        "False"
      ],
      "variant_3": [
        "вкладеним",
        "False"
      ]
    },
    {
      "test": "(C++) Порядковий номер елемента в масиві називається",
      "variant_1": [
        "розмірністю",
        "False"
      ],
      "variant_2": [
        " індексом",
        "True"
      ],
      "variant_3": [
        "порядковим номером",
        "False"
      ]
    },
    {
      "test": "(C++) Кількість елементів масиву називається",
      "variant_1": [
        "потужністю масиву",
        "False"
      ],
      "variant_2": [
        " розмірністю масиву",
        "True"
      ],
      "variant_3": [
        " довжиною масиву",
        "True"
      ]
    },
    {
      "test": "(C++) Для доступу до окремого елемента масиву застосовується операція індексування",
      "variant_1": [
        " [ ]",
        "True"
      ],
      "variant_2": [
        " ( )",
        "False"
      ],
      "variant_3": [
        "{ }",
        "False"
      ]
    },
    {
      "test": "(C++) В оголошенні масиву після його імені в квадратних дужках вказується",
      "variant_1": [
        " максимальна кількість елементів масиву",
        "True"
      ],
      "variant_2": [
        "фактична кількість елементів масиву",
        "False"
      ],
      "variant_3": [
        "розмір пам'яті, необхідний для розташування масиву",
        "False"
      ]
    },
    {
      "test": "Синтаксис оголошення змінної матричного типу в мові С++ виглядає так:",
      "variant_1": [
        "<тип елементів> <ім‘я матриці > [<кількість стовпців>] [<кількість рядків>];",
        "False"
      ],
      "variant_2": [
        " <тип елементів> <ім‘я матриці > [<кількість рядків>] [<кількість стовпців>];",
        "True"
      ],
      "variant_3": [
        "<тип елементів> <ім‘я матриці > [<кількість рядків> , <кількість стовпців>];",
        "False"
      ]
    },
    {
      "test": "(C++) Доступ до елементів матриці здійснюється операцією індексування",
      "variant_1": [
        "<ім‘я матриці> [<номер рядка> , <номер стовпця>]",
        "False"
      ],
      "variant_2": [
        "<ім‘я матриці> [<номер стовпця>][<номер рядка>]",
        "False"
      ],
      "variant_3": [
        " <ім‘я матриці> [<номер рядка>][<номер стовпця>]",
        "True"
      ]
    },
    {
      "test": "(C++) Результатом обчислення сум елементів матриці A[m][n] по рядках буде",
      "variant_1": [
        "число",
        "False"
      ],
      "variant_2": [
        " одновимірний масив розмірності m",
        "True"
      ],
      "variant_3": [
        "одновимірний масив розмірності n",
        "False"
      ]
    },
    {
      "test": "(C++) Результатом обчислення сум елементів матриці A[m][n] по стовпцях буде",
      "variant_1": [
        " одновимірний масив розмірності n",
        "True"
      ],
      "variant_2": [
        "одновимірний масив розмірності m",
        "False"
      ],
      "variant_3": [
        "число",
        "False"
      ]
    },
    {
      "test": "(C++) Результатом транспонування матриці A[m][n] буде матриця",
      "variant_1": [
        "A[m][m]",
        "False"
      ],
      "variant_2": [
        "A[n][n]",
        "False"
      ],
      "variant_3": [
        " A[n][m]",
        "True"
      ]
    },
    {
      "test": "(C++) Номером останнього рядку матриці A[m][n] є",
      "variant_1": [
        " m – 1",
        "True"
      ],
      "variant_2": [
        "n – 1",
        "False"
      ],
      "variant_3": [
        "m",
        "False"
      ]
    },
    {
      "test": "(C++) Номером останнього стовпця матриці A[m][n] є",
      "variant_1": [
        "n",
        "False"
      ],
      "variant_2": [
        "m – 1",
        "False"
      ],
      "variant_3": [
        " n – 1",
        "True"
      ]
    },
    {
      "test": "(C++) Синтаксис оголошення змінної рядкового типу, як масиву символів, такий:",
      "variant_1": [
        " char < ім‘я змінної > [<загальна довжина рядка>]",
        "True"
      ],
      "variant_2": [
        "char < ім‘я змінної > [<поточна довжина рядка>]",
        "False"
      ],
      "variant_3": [
        "char < ім‘я змінної >",
        "False"
      ]
    },
    {
      "test": "(C++) Максимальне значення довжини рядка типу масиву символів",
      "variant_1": [
        "становить 1024 символів",
        "False"
      ],
      "variant_2": [
        " становить 255 символів",
        "True"
      ],
      "variant_3": [
        "не обмежене",
        "False"
      ]
    },
    {
      "test": "(C++) Доступ до i-го символу рядку char str[10] можна здійснювати так:",
      "variant_1": [
        " str[i]",
        "True"
      ],
      "variant_2": [
        "str(i)",
        "False"
      ],
      "variant_3": [
        "str{i}",
        "False"
      ]
    },
    {
      "test": "(C++) Довжину рядку s типу масиву символів можна визначити за допомогою функції",
      "variant_1": [
        " strlen(s);",
        "True"
      ],
      "variant_2": [
        "s.length;",
        "False"
      ],
      "variant_3": [
        "Length(s);",
        "False"
      ]
    },
    {
      "test": "(C++) Структура struct – це",
      "variant_1": [
        "простий тип даних",
        "False"
      ],
      "variant_2": [
        " складений тип даних – об’єднання фіксованої кількості змінних одного або декількох типів",
        "True"
      ],
      "variant_3": [
        "послідовність однотипних даних",
        "False"
      ]
    },
    {
      "test": "(C++) Змінні, що входять до складу структури struct, називаються",
      "variant_1": [
        "екземплярами",
        "False"
      ],
      "variant_2": [
        "елементами",
        "False"
      ],
      "variant_3": [
        " полями",
        "True"
      ]
    },
    {
      "test": "(C++) Звернення до полів структури struct здійснюється через складене ім’я, що містить операцію доступу",
      "variant_1": [
        " . (крапка)",
        "True"
      ],
      "variant_2": [
        " ->",
        "True"
      ],
      "variant_3": [
        "::",
        "False"
      ]
    },
    {
      "test": "(C++) Поле структури struct може мати",
      "variant_1": [
        "будь-який тип",
        "False"
      ],
      "variant_2": [
        " будь-який тип, окрім файлового",
        "True"
      ],
      "variant_3": [
        "будь-який тип, окрім struct",
        "False"
      ]
    },
    {
      "test": "(C++) Для екземплярів структур struct як цілісних об’єктів означені операції",
      "variant_1": [
        " присвоєння",
        "True"
      ],
      "variant_2": [
        "додавання",
        "False"
      ],
      "variant_3": [
        "порівняння",
        "False"
      ]
    },
    {
      "test": "CLR – це:",
      "variant_1": [
        "віртуальна машиною Java",
        "False"
      ],
      "variant_2": [
        " складова частина .NET Framework, яка підтримує багатомовне програмування",
        "True"
      ],
      "variant_3": [
        "складова середовища об’єктно-орієнтованого програмування",
        "False"
      ]
    },
    {
      "test": "MSIL – це:",
      "variant_1": [
        "складова частина .NET Framework, яка підтримує багатомовне програмування",
        "False"
      ],
      "variant_2": [
        "самодостатня мова програмування",
        "False"
      ],
      "variant_3": [
        " спеціальний псевдокод, іменований проміжним мовою Microsoft",
        "True"
      ]
    },
    {
      "test": "JIT-компілятор здійснює перетворення",
      "variant_1": [
        " MSIL-коду в її \"рідний\" код на необхідній основі",
        "True"
      ],
      "variant_2": [
        "програмного коду на мові С# у виконуваний код",
        "False"
      ],
      "variant_3": [
        "програмного коду на мові С# у MSIL-код",
        "False"
      ]
    },
    {
      "test": "(С#) Простір імен",
      "variant_1": [
        "позначається ключовим словом spacename",
        "False"
      ],
      "variant_2": [
        " позначається ключовим словом namespace",
        "True"
      ],
      "variant_3": [
        " є способом, завдяки якому .NET уникає конфліктів імен між класами",
        "True"
      ]
    },
    {
      "test": "(C#) Директива using",
      "variant_1": [
        " дозволяє створювати псевдоніми простору імен або типу",
        "True"
      ],
      "variant_2": [
        "забороняє використання типу в просторі імен без зазначення його імені",
        "False"
      ],
      "variant_3": [
        " дозволяє використання типу в просторі імен без зазначення його імені",
        "True"
      ]
    },
    {
      "test": "(С#) Консольна програма містить метод",
      "variant_1": [
        " Main()",
        "True"
      ],
      "variant_2": [
        "main()",
        "False"
      ],
      "variant_3": [
        "Program()",
        "False"
      ]
    },
    {
      "test": "(C#) Клас Console розташований в бібліотеці",
      "variant_1": [
        " System",
        "True"
      ],
      "variant_2": [
        "Windows",
        "False"
      ],
      "variant_3": [
        "iostream",
        "False"
      ]
    },
    {
      "test": "(C#) Метод WriteLine() класу Console здійснює",
      "variant_1": [
        "введення числових даних з клавіатури",
        "False"
      ],
      "variant_2": [
        "введення рядкових даних з клавіатури",
        "False"
      ],
      "variant_3": [
        " виведення даних на екран монітору",
        "True"
      ]
    },
    {
      "test": "(C#) Метод ReadLine() класу Console здійснює",
      "variant_1": [
        " введення рядкових даних з клавіатури",
        "True"
      ],
      "variant_2": [
        "введення будь-яких даних з клавіатури",
        "False"
      ],
      "variant_3": [
        "виведення інформації на екран монітору",
        "False"
      ]
    },
    {
      "test": "(C#) Значення типу char – це:",
      "variant_1": [
        "символ Unicode, що міститься в одному байті",
        "False"
      ],
      "variant_2": [
        "символ ASCII, що міститься в одному байті",
        "False"
      ],
      "variant_3": [
        " символ Unicode, що міститься в двох байтах",
        "True"
      ]
    },
    {
      "test": "(C#) Перетворення вбудованих типів даних бувають",
      "variant_1": [
        " явними",
        "True"
      ],
      "variant_2": [
        " неявними",
        "True"
      ],
      "variant_3": [
        "умовними",
        "False"
      ]
    },
    {
      "test": "(C#) При неявному перетворенні типів",
      "variant_1": [
        " змінна, що стоїть зліва від знаку присвоєння, повинна мати більший розмір пам'яті",
        "True"
      ],
      "variant_2": [
        "змінна, що стоїть справа від знаку присвоєння, повинна мати більший розмір пам'яті",
        "False"
      ],
      "variant_3": [
        "перед змінною, що стоїть справа від знаку присвоєння, в круглих дужках зазначається потрібний тип даних",
        "False"
      ]
    },
    {
      "test": "(C#) При явному перетворенні типів перед змінною, що стоїть справа від знаку присвоєння, зазначається потрібний тип даних",
      "variant_1": [
        "в фігурних дужках",
        "False"
      ],
      "variant_2": [
        "в лапках",
        "False"
      ],
      "variant_3": [
        " в круглих дужках",
        "True"
      ]
    },
    {
      "test": "(C#) В оголошенні перерахованого типу даних використовується ключове слово",
      "variant_1": [
        " enum",
        "True"
      ],
      "variant_2": [
        "struct",
        "False"
      ],
      "variant_3": [
        "array",
        "False"
      ]
    },
    {
      "test": "(С#) Оголошення одновимірного масиву має такий стнтаксис:",
      "variant_1": [
        "тип ім’я_масиву[] = new тип[розмір масиву];",
        "False"
      ],
      "variant_2": [
        " тип[] ім’я_масиву = new тип[розмір масиву];",
        "True"
      ],
      "variant_3": [
        "тип ім’я_масиву = new тип[розмір масиву];",
        "False"
      ]
    },
    {
      "test": "(C#) Доступ до елементів одновимірного масиву здійснюється по індексу, що зазначається:",
      "variant_1": [
        " в квадратних дужках",
        "True"
      ],
      "variant_2": [
        "в круглих дужках",
        "False"
      ],
      "variant_3": [
        "в фігурних дужках",
        "False"
      ]
    },
    {
      "test": "(С#) оголошення двовимірного масиву має такий синтаксис:",
      "variant_1": [
        "int[,] numbers1 = new int[кількість рядків][кількість стовпців];",
        "False"
      ],
      "variant_2": [
        " int[,] numbers1 = new int[кількість рядків, кількість стовпців];",
        "True"
      ],
      "variant_3": [
        "int[][] numbers1 = new int[кількість рядків, кількість стовпців];",
        "False"
      ]
    },
    {
      "test": "(C#) Доступ до елементів двовимірного масиву numbers здійснюється так:",
      "variant_1": [
        "numbers(номер рядку, номер стовпця)",
        "False"
      ],
      "variant_2": [
        "numbers[номер рядку][номер стовпця]",
        "False"
      ],
      "variant_3": [
        " numbers[номер рядку, номер стовпця]",
        "True"
      ]
    },
    {
      "test": "(C#) Кількість елементів масиву numbers можна визначити так:",
      "variant_1": [
        "numbers.Count",
        "False"
      ],
      "variant_2": [
        "numbers.Size",
        "False"
      ],
      "variant_3": [
        " numbers.Length",
        "True"
      ]
    },
    {
      "test": "(C#) Додавання елементів у список класу List здійснюється за допомогою методів",
      "variant_1": [
        " Add",
        "True"
      ],
      "variant_2": [
        " Insert",
        "True"
      ],
      "variant_3": [
        "Append",
        "False"
      ]
    },
    {
      "test": "(C#) Видалення елементів зі списку класу List здійснюється за допомогою методів",
      "variant_1": [
        " RemoveAt",
        "True"
      ],
      "variant_2": [
        "Delete",
        "False"
      ],
      "variant_3": [
        " Remove",
        "True"
      ]
    },
    {
      "test": "(C#) Операторами циклів є:",
      "variant_1": [
        " foreach",
        "True"
      ],
      "variant_2": [
        " for",
        "True"
      ],
      "variant_3": [
        "switch",
        "False"
      ]
    },
    {
      "test": "(C#) Оператор циклу foreach доцільно використовувати для",
      "variant_1": [
        "додавання елементів в колекцію",
        "False"
      ],
      "variant_2": [
        "видалення елементів з колекції",
        "False"
      ],
      "variant_3": [
        " отримання (читання) даних з колекції",
        "True"
      ]
    },
    {
      "test": "Функція в C#:",
      "variant_1": [
        "повинна повертати значення",
        "False"
      ],
      "variant_2": [
        "не повинна повертати значення",
        "False"
      ],
      "variant_3": [
        " може повертати чи не повертати значення",
        "True"
      ]
    },
    {
      "test": "(C#) Для передачі в функцію параметрів по посиланню можна використовувати ключові слова",
      "variant_1": [
        " ref",
        "True"
      ],
      "variant_2": [
        " out",
        "True"
      ],
      "variant_3": [
        "var",
        "False"
      ]
    },
    {
      "test": "(C#) Ключові слова ref і out зазначаються",
      "variant_1": [
        " перед типом параметру",
        "True"
      ],
      "variant_2": [
        "перед іменем параметру",
        "False"
      ],
      "variant_3": [
        "після імені параметру",
        "False"
      ]
    },
    {
      "test": "(C#) Метод IsNullOrEmpty(s) класу String повертає true, якщо:",
      "variant_1": [
        " значення рядку s дорівнює null",
        "True"
      ],
      "variant_2": [
        " рядок s порожній",
        "True"
      ],
      "variant_3": [
        "рядок s містить набір символів пробілу і/або табуляції",
        "False"
      ]
    },
    {
      "test": "(C#) Метод Compare(s1, s2) класу String повертає 0, якщо:",
      "variant_1": [
        "рядок s1 більше рядку s2",
        "False"
      ],
      "variant_2": [
        " рядки s1 і s2 співпадають",
        "True"
      ],
      "variant_3": [
        "рядок s1 менше рядку s2",
        "False"
      ]
    },
    {
      "test": "(C#) Метод IndexOf() класу String",
      "variant_1": [
        " повертає індекс першого символу підрядку, який міститься в рядку",
        "True"
      ],
      "variant_2": [
        "повертає true, якщо підрядок міститься в рядку",
        "False"
      ],
      "variant_3": [
        " повертає -1, якщо підрядок не міститься в рядку",
        "True"
      ]
    },
    {
      "test": "(C#) Метод Remove() класу String",
      "variant_1": [
        " видаляє вказану кількість символів с початку рядку",
        "True"
      ],
      "variant_2": [
        "обрізує рядок, починаючи з заданого символу",
        "False"
      ],
      "variant_3": [
        "видаляє задану кількість символів, починаючи з заданої позиції",
        "False"
      ]
    },
    {
      "test": "(C#) Отримати підрядок з рядку класу String, починаючи з вказаної позиції можна за допомогою методу",
      "variant_1": [
        "Contains()",
        "False"
      ],
      "variant_2": [
        " Substring()",
        "True"
      ],
      "variant_3": [
        "IndexOf()",
        "False"
      ]
    },
    {
      "test": "(C#) Замінити вказаний підрядок на інший в рядку класу String можна за допомогою методу",
      "variant_1": [
        "Contains()",
        "False"
      ],
      "variant_2": [
        "Substring()",
        "False"
      ],
      "variant_3": [
        " Replace()",
        "True"
      ]
    },
    {
      "test": "(C#) Розбити рядок класу String на декілька підрядків по вказаному символу можна за допомогою методу",
      "variant_1": [
        " Split()",
        "True"
      ],
      "variant_2": [
        "Insert()",
        "False"
      ],
      "variant_3": [
        "Remove()",
        "False"
      ]
    },
    {
      "test": "(C#) Метод Contains() класу String",
      "variant_1": [
        "здійснює порівняння двох рядків",
        "False"
      ],
      "variant_2": [
        "повертає довжину рядку",
        "False"
      ],
      "variant_3": [
        "перевіряє наявність підрядка в рядку",
        "True"
      ]
    },
    {
      "test": "Базовими поняттями об’єктно-орієнтованого програмування є",
      "variant_1": [
        " клас",
        "True"
      ],
      "variant_2": [
        " об'єкт",
        "True"
      ],
      "variant_3": [
        "покажчик",
        "False"
      ]
    },
    {
      "test": "Базовими концепціями об’єктно-орієнтованого програмування є",
      "variant_1": [
        " інкапсуляція",
        "True"
      ],
      "variant_2": [
        "інтеграція",
        "False"
      ],
      "variant_3": [
        " поліморфізм",
        "True"
      ]
    },
    {
      "test": "Функції – члени класу називаються",
      "variant_1": [
        " методами",
        "True"
      ],
      "variant_2": [
        "процедурами",
        "False"
      ],
      "variant_3": [
        "атрибутами",
        "False"
      ]
    },
    {
      "test": "Клас в ООП – це",
      "variant_1": [
        " опис деякої структури програми, яка володіє набором внутрішніх змінних  і функцій, що мають доступ до цих змінних",
        "True"
      ],
      "variant_2": [
        "сукупність даних (змінних) і способів роботи з ними (функцій)",
        "False"
      ],
      "variant_3": [
        "стандартний тип даних",
        "False"
      ]
    },
    {
      "test": "Інкапсуляція в об’єктно-орієнтованому програмуванні – це",
      "variant_1": [
        "процес, за допомогою якого один клас може набувати властивостей іншого",
        "False"
      ],
      "variant_2": [
        " механізм, який об'єднує дані і код, який маніпулює цими даними",
        "True"
      ],
      "variant_3": [
        "властивість, яка дозволяє одне і те ж ім'я методу класу використовувати для вирішення декількох схожих, але технічно різних завдань",
        "False"
      ]
    },
    {
      "test": "Поліморфізм в об’єктно-орієнтованому програмуванні – це",
      "variant_1": [
        "процес, за допомогою якого один клас може набувати властивостей іншого",
        "False"
      ],
      "variant_2": [
        "механізм, який об'єднує дані і код, який маніпулює цими даними",
        "False"
      ],
      "variant_3": [
        " властивість, яка дозволяє одне і те ж ім'я методу класу використовувати для вирішення декількох схожих, але технічно різних завдань",
        "True"
      ]
    },
    {
      "test": "Успадкування в об’єктно-орієнтованому програмуванні – це",
      "variant_1": [
        " процес, за допомогою якого один клас може набувати властивостей іншого",
        "True"
      ],
      "variant_2": [
        "метод розв’язання задачі, при якому об'єкти різного роду об'єднуються загальною концепцією",
        "False"
      ],
      "variant_3": [
        "механізм, який об'єднує дані і код, який маніпулює цими даними",
        "False"
      ]
    },
    {
      "test": "(С++) Доступ до членів класу здійснюється з використанням операторів",
      "variant_1": [
        " . (крапка)",
        "True"
      ],
      "variant_2": [
        " ->",
        "True"
      ],
      "variant_3": [
        "::",
        "False"
      ]
    },
    {
      "test": "(С++) Реалізація методу класу може здійснюватися",
      "variant_1": [
        "тільки в межах опису класу",
        "False"
      ],
      "variant_2": [
        "тільки за межами опису класу",
        "False"
      ],
      "variant_3": [
        " як в межах опису класу, так і зовні від нього",
        "True"
      ]
    },
    {
      "test": "(С++) Класи, на основі яких будуються інші класи, називаються",
      "variant_1": [
        " базовими",
        "True"
      ],
      "variant_2": [
        "дочірніми",
        "False"
      ],
      "variant_3": [
        "похідними",
        "False"
      ]
    },
    {
      "test": "(С++) Класи, які будуються на основі інших класів, називаються",
      "variant_1": [
        "батьківськими",
        "False"
      ],
      "variant_2": [
        " похідними",
        "True"
      ],
      "variant_3": [
        "базовими",
        "False"
      ]
    },
    {
      "test": "(С++) Віртуальна функція позначається ключовим словом virtual",
      "variant_1": [
        "в похідному класі",
        "False"
      ],
      "variant_2": [
        " в базовому класі",
        "True"
      ],
      "variant_3": [
        "і в базовому і в похідному класі",
        "False"
      ]
    },
    {
      "test": "(С++) При успадкуванні похідний клас набуває властивості та методи базового класу",
      "variant_1": [
        " за виключенням описаних з областю видимості private",
        "True"
      ],
      "variant_2": [
        "всі без виключення",
        "False"
      ],
      "variant_3": [
        "за виключенням описаних з модифікатором protected:",
        "False"
      ]
    },
    {
      "test": "(С++) До захищеного члену класу (protected:) можуть отримати доступ",
      "variant_1": [
        "тільки члени цього ж класу",
        "False"
      ],
      "variant_2": [
        " члени цього ж класу та похідних класів",
        "True"
      ],
      "variant_3": [
        "члени будь-яких класів",
        "False"
      ]
    },
    {
      "test": "(С++) Клас, який містить віртуальну функцію, називається",
      "variant_1": [
        " поліморфним",
        "True"
      ],
      "variant_2": [
        "віртуальним",
        "False"
      ],
      "variant_3": [
        "абстрактним",
        "False"
      ]
    },
    {
      "test": "(С++) Чисто віртуальна функція – це функція,",
      "variant_1": [
        "не перевизначена в похідному класі",
        "False"
      ],
      "variant_2": [
        " оголошена в базовому класі, яка не має в ньому визначення",
        "True"
      ],
      "variant_3": [
        "оголошена з модифікатором virtual",
        "False"
      ]
    },
    {
      "test": "(С++) Клас, що містить хоча б одну чисто віртуальну функцію, називається",
      "variant_1": [
        " абстрактним",
        "True"
      ],
      "variant_2": [
        "поліморфним",
        "False"
      ],
      "variant_3": [
        "віртуальним",
        "False"
      ]
    },
    {
      "test": "(С++) Абстрактний клас",
      "variant_1": [
        " можна використовувати для оголошення покажчиків та посилань",
        "True"
      ],
      "variant_2": [
        " не можна використовувати для створення об’єктів",
        "True"
      ],
      "variant_3": [
        "можна використовувати для створення об’єктів",
        "False"
      ]
    },
    {
      "test": "(С++) Конструктор класу",
      "variant_1": [
        " є методом класу, який полегшує програмам ініціалізацію елементів даних класу",
        "True"
      ],
      "variant_2": [
        "є функцією, що повертає значення типу bool",
        "False"
      ],
      "variant_3": [
        " є функцією, що не повертає значення",
        "True"
      ]
    },
    {
      "test": "(С++) Деструктор класу зазвичай використовується для",
      "variant_1": [
        " звільнення пам'яті при знищенні об'єкта",
        "True"
      ],
      "variant_2": [
        "ініціалізації елементів даних класу",
        "False"
      ],
      "variant_3": [
        "виклику методів класу",
        "False"
      ]
    },
    {
      "test": "(С++) В описі класу",
      "variant_1": [
        " конструктор може бути відсутній",
        "True"
      ],
      "variant_2": [
        "може бути тільки один конструктор",
        "False"
      ],
      "variant_3": [
        " може бути декілька конструкторів з різним набором параметрів",
        "True"
      ]
    },
    {
      "test": "(С++) При завершенні роботи програми",
      "variant_1": [
        " автоматично викликається деструктор класу для кожного об'єкту",
        "True"
      ],
      "variant_2": [
        "автоматично викликається деструктор класу для всіх об'єктів",
        "False"
      ],
      "variant_3": [
        "програмно викликається конструктор класу для знищення відразу всіх об’єктів",
        "False"
      ]
    },
    {
      "test": "(C#) Методи класу, що не повертають значення",
      "variant_1": [
        " містять ключове слово void перед іменем методу",
        "True"
      ],
      "variant_2": [
        "містять ключове слово void в круглих дужках після імені методу",
        "False"
      ],
      "variant_3": [
        "містять оператор return",
        "False"
      ]
    },
    {
      "test": "(C#) При оголошенні члену класу без модифікатора доступу він є",
      "variant_1": [
        " закритим",
        "True"
      ],
      "variant_2": [
        "відкритим",
        "False"
      ],
      "variant_3": [
        "захищеним",
        "False"
      ]
    },
    {
      "test": "(C#) Для відкритого члену класу застосовується модифікатор",
      "variant_1": [
        "private",
        "False"
      ],
      "variant_2": [
        " public",
        "True"
      ],
      "variant_3": [
        "protected",
        "False"
      ]
    },
    {
      "test": "(C#) Для захищеного члену класу застосовується модифікатор",
      "variant_1": [
        "private",
        "False"
      ],
      "variant_2": [
        "public",
        "False"
      ],
      "variant_3": [
        " protected",
        "True"
      ]
    },
    {
      "test": "(C#) Член класу, оголошений з модифікатором protected  має доступ",
      "variant_1": [
        "лише для членів свого класу",
        "False"
      ],
      "variant_2": [
        " для членів свого класу, а також для похідних класів",
        "True"
      ],
      "variant_3": [
        "з будь-якої ділянки програмного коду",
        "False"
      ]
    },
    {
      "test": "(C#) Ключове слово virtual зазначається",
      "variant_1": [
        "в заголовку опису методу в базовому класі перед модифікатором доступу",
        "False"
      ],
      "variant_2": [
        " в заголовку опису методу в базовому класі після модифікатора доступу",
        "True"
      ],
      "variant_3": [
        "в заголовку опису методу в похідному класі після модифікатора доступу",
        "False"
      ]
    },
    {
      "test": "(C#) Ключове слово override зазначається",
      "variant_1": [
        " в заголовку опису методу в похідному класі після модифікатора доступу",
        "True"
      ],
      "variant_2": [
        "в заголовку опису методу в базовому класі після модифікатора доступу",
        "False"
      ],
      "variant_3": [
        "в заголовку опису методу в похідному класі перед модифікатором доступу",
        "False"
      ]
    },
    {
      "test": "(C#) При перевизначенні методу класу",
      "variant_1": [
        "віртуальний метод повинен бути визначений як статичний (static)",
        "False"
      ],
      "variant_2": [
        "віртуальний метод повинен бути визначений як абстрактний (abstract)",
        "False"
      ],
      "variant_3": [
        " сигнатури типу у віртуального і метода-замінника повинні збігатися",
        "True"
      ]
    },
    {
      "test": "(C#) Динамічна диспетчеризація методів класу – це",
      "variant_1": [
        " механізм виклику перевизначеного методу під час виконання програми",
        "True"
      ],
      "variant_2": [
        "механізм виклику перевизначеного методу в період компіляції",
        "False"
      ],
      "variant_3": [
        "механізм контролю коректності перевизначеного методу",
        "False"
      ]
    },
    {
      "test": "(C#) Модифікатор abstract зазначається в заголовку методу класу",
      "variant_1": [
        "перед модифікатором доступу",
        "False"
      ],
      "variant_2": [
        "після імені методу та двокрапки",
        "False"
      ],
      "variant_3": [
        " після модифікатора доступу",
        "True"
      ]
    },
    {
      "test": "(C#) Модифікатор abstract можна використовувати",
      "variant_1": [
        "тільки до static-методів класу",
        "False"
      ],
      "variant_2": [
        " для всіх методів, окрім статичних (static)",
        "True"
      ],
      "variant_3": [
        "для будь-яких методів",
        "False"
      ]
    },
    {
      "test": "(C#) Усі похідні класи абстрактних класів повинні",
      "variant_1": [
        " перевизначати абстрактні методи базового класу",
        "True"
      ],
      "variant_2": [
        "перевизначати всі методи базового класу",
        "False"
      ],
      "variant_3": [
        "бути статичними (static)",
        "False"
      ]
    },
    {
      "test": "(C#) Ім’я інтерфейсу зазначається",
      "variant_1": [
        "після імені класу в круглих дужках",
        "False"
      ],
      "variant_2": [
        " після імені класу та двокрапки",
        "True"
      ],
      "variant_3": [
        "в списку параметрів методів класу",
        "False"
      ]
    },
    {
      "test": "(C#) Події – це члени класу, які оголошуються з використанням ключового слова",
      "variant_1": [
        "property",
        "False"
      ],
      "variant_2": [
        " event",
        "True"
      ],
      "variant_3": [
        "delegate",
        "False"
      ]
    },
    {
      "test": "(C#) Події класу активізуються за допомогою",
      "variant_1": [
        "інтерфейсу",
        "False"
      ],
      "variant_2": [
        " делегата",
        "True"
      ],
      "variant_3": [
        "класу",
        "False"
      ]
    },
    {
      "test": "(C#) Для включення події в список обробників подій класів застосовується ключове слово",
      "variant_1": [
        "insert",
        "False"
      ],
      "variant_2": [
        " add",
        "True"
      ],
      "variant_3": [
        "append",
        "False"
      ]
    },
    {
      "test": "(C#) Для видалення події зі списку обробників подій класів застосовується ключове слово",
      "variant_1": [
        " remove",
        "True"
      ],
      "variant_2": [
        "delete",
        "False"
      ],
      "variant_3": [
        "cancel",
        "False"
      ]
    },
    {
      "test": "(Java) Клас, який успадковується, називається",
      "variant_1": [
        "батьківським (parent)",
        "False"
      ],
      "variant_2": [
        " базовим (base)",
        "True"
      ],
      "variant_3": [
        " суперкласом (superclass)",
        "True"
      ]
    },
    {
      "test": "(Java) В описі підкласу перед іменем суперкласу застосовується ключове слово",
      "variant_1": [
        " extends",
        "True"
      ],
      "variant_2": [
        "superclass",
        "False"
      ],
      "variant_3": [
        "parent",
        "False"
      ]
    },
    {
      "test": "(Java) Класи, які не можуть мати нащадків позначаються модифікатором",
      "variant_1": [
        "private",
        "False"
      ],
      "variant_2": [
        " final",
        "True"
      ],
      "variant_3": [
        "friendly",
        "False"
      ]
    },
    {
      "test": "(Java) Модифікатором класу, який встановлюється за замовчуванням, є",
      "variant_1": [
        "public",
        "False"
      ],
      "variant_2": [
        " friendly",
        "True"
      ],
      "variant_3": [
        "abstract",
        "False"
      ]
    },
    {
      "test": "(С++Builder) Проект (Project) – це",
      "variant_1": [
        " сукупність файлів, з яких складається програма",
        "True"
      ],
      "variant_2": [
        "сукупність компонентів, з яких складається інтерфейс програми",
        "False"
      ],
      "variant_3": [
        "сукупність інструментальних засобів для створення програми",
        "False"
      ]
    },
    {
      "test": "(С++Builder) Компонент (component) – це",
      "variant_1": [
        "графічне зображення, що відображається в вікні проекту",
        "False"
      ],
      "variant_2": [
        " функціонально закінчена ділянка двійкового коду, яка виконує деяку задачу",
        "True"
      ],
      "variant_3": [
        "елемент списку панелі Tool Palette",
        "False"
      ]
    },
    {
      "test": "(С++Builder) Форма (Form) – це",
      "variant_1": [
        "інструментальний засіб IDE RAD Studio Embarcadero",
        "False"
      ],
      "variant_2": [
        "графічне зображення вікна проекту",
        "False"
      ],
      "variant_3": [
        " компонент, який володіє властивостями вікна Windows і призначений для розташування інших компонентів",
        "True"
      ]
    },
    {
      "test": "(С++Builder) Властивість (property) компоненту визначає",
      "variant_1": [
        " вигляд компоненту",
        "True"
      ],
      "variant_2": [
        " поведінку компоненту",
        "True"
      ],
      "variant_3": [
        "стан інтерфейсу",
        "False"
      ]
    },
    {
      "test": "(С++Builder) Подія (event) компоненту – це",
      "variant_1": [
        "результат взаємодії користувача з IDE RAD Studio Embarcadero",
        "False"
      ],
      "variant_2": [
        "будь-який метод класу",
        "False"
      ],
      "variant_3": [
        " метод, що викликається в компоненті в результаті взаємодії його з користувачем",
        "True"
      ]
    },
    {
      "test": "(С++Builder) Інспектор об’єктів містить такі закладки:",
      "variant_1": [
        " Events",
        "True"
      ],
      "variant_2": [
        "Components",
        "False"
      ],
      "variant_3": [
        " Properties",
        "True"
      ]
    },
    {
      "test": "(С++Builder) Файлова структура проекту відображається в вікні",
      "variant_1": [
        "Палітри інструментів",
        "False"
      ],
      "variant_2": [
        " Менеджера проекту",
        "True"
      ],
      "variant_3": [
        "Інспектора об’єктів",
        "False"
      ]
    },
    {
      "test": "(С++Builder) Файл, що містить опис класу форми, має розширення",
      "variant_1": [
        " h",
        "True"
      ],
      "variant_2": [
        "cpp",
        "False"
      ],
      "variant_3": [
        "hpp",
        "False"
      ]
    },
    {
      "test": "(С++Builder) На панелі Structure в режимі проектування відображається",
      "variant_1": [
        " структура компонентів",
        "True"
      ],
      "variant_2": [
        "структура програмного коду",
        "False"
      ],
      "variant_3": [
        "список типів проектів IDE RAD Studio Embarcadero",
        "False"
      ]
    },
    {
      "test": "(С++Builder) Властивості Width i Height компонентів визначають",
      "variant_1": [
        " розміри компоненту",
        "True"
      ],
      "variant_2": [
        "місце розташування компоненту",
        "False"
      ],
      "variant_3": [
        "вирівнювання компоненту",
        "False"
      ]
    },
    {
      "test": "(С++Builder) Місце розташування компоненту в контейнері визначається властивостями",
      "variant_1": [
        "Width i Height",
        "False"
      ],
      "variant_2": [
        " Left і Top",
        "True"
      ],
      "variant_3": [
        "Left i Height",
        "False"
      ]
    },
    {
      "test": "(С++Builder) Вирівнювання компоненту по лівому краю контейнера виконується при значенні властивості Align",
      "variant_1": [
        " alLeft",
        "True"
      ],
      "variant_2": [
        "Left",
        "False"
      ],
      "variant_3": [
        "akLeft",
        "False"
      ]
    },
    {
      "test": "(С++Builder) Обмеження максимальної ширини компонента виконується при встановленні потрібного значення властивості Constraints",
      "variant_1": [
        "WidthMax",
        "False"
      ],
      "variant_2": [
        " MaxWidth",
        "True"
      ],
      "variant_3": [
        "MaxW",
        "False"
      ]
    },
    {
      "test": "(С++Builder) Відображення контекстних підказок компоненту забезпечується властивостями",
      "variant_1": [
        "Label",
        "False"
      ],
      "variant_2": [
        " ShowHint",
        "True"
      ],
      "variant_3": [
        " Hint",
        "True"
      ]
    },
    {
      "test": "(С++Builder) Керування доступом до компонента здійснюється за допомогою властивості",
      "variant_1": [
        " Enabled",
        "True"
      ],
      "variant_2": [
        "Visible",
        "False"
      ],
      "variant_3": [
        "Show",
        "False"
      ]
    },
    {
      "test": "(С++Builder) Надпис на кнопках міститься у властивості",
      "variant_1": [
        " Caption",
        "True"
      ],
      "variant_2": [
        "Text",
        "False"
      ],
      "variant_3": [
        "Label",
        "False"
      ]
    },
    {
      "test": "(С++Builder) В натиснутому стані може бути зафіксована кнопка",
      "variant_1": [
        " SpeedButton",
        "True"
      ],
      "variant_2": [
        "Button",
        "False"
      ],
      "variant_3": [
        "BitBtn",
        "False"
      ]
    },
    {
      "test": "(С++Builder) Вимкнути Timer можна таким чином",
      "variant_1": [
        " Timer–>Enabled = false",
        "True"
      ],
      "variant_2": [
        " Timer–>Interval = 0",
        "True"
      ],
      "variant_3": [
        "Timer–>Visible = false",
        "False"
      ]
    },
    {
      "test": "(С++Builder) Надписи кнопок компоненту RadioGroup містяться у властивості",
      "variant_1": [
        "Caption",
        "False"
      ],
      "variant_2": [
        "Lines",
        "False"
      ],
      "variant_3": [
        " Items",
        "True"
      ]
    },
    {
      "test": "(С++Builder) Номер обраного перемикача в групі RadioGroup визначається властивістю",
      "variant_1": [
        " ItemIndex",
        "True"
      ],
      "variant_2": [
        "Index",
        "False"
      ],
      "variant_3": [
        "Count",
        "False"
      ]
    },
    {
      "test": "(С++Builder) Стан перемикача CheckBox визначається властивістю",
      "variant_1": [
        " Checked",
        "True"
      ],
      "variant_2": [
        "Selected",
        "False"
      ],
      "variant_3": [
        "Marked",
        "False"
      ]
    },
    {
      "test": "(С++Builder) Рядок, що редагується в полі Edit, міститься у властивості",
      "variant_1": [
        "Caption",
        "False"
      ],
      "variant_2": [
        " Text",
        "True"
      ],
      "variant_3": [
        "String",
        "False"
      ]
    },
    {
      "test": "(С++Builder) Заборону внесення змін в полях редагування можна здійснити за допомогою властивості",
      "variant_1": [
        "NotEdit",
        "False"
      ],
      "variant_2": [
        " ReadOnly",
        "True"
      ],
      "variant_3": [
        "EnabledEdit",
        "False"
      ]
    },
    {
      "test": "(С++Builder) Багаторядковий текст можна відображати в компонентах",
      "variant_1": [
        "Edit",
        "False"
      ],
      "variant_2": [
        " Label",
        "True"
      ],
      "variant_3": [
        " Memo",
        "True"
      ]
    },
    {
      "test": "(С++Builder) Текст багаторядкових полів редагування міститься у властивості",
      "variant_1": [
        " Lines",
        "True"
      ],
      "variant_2": [
        "Items",
        "False"
      ],
      "variant_3": [
        "Strings",
        "False"
      ]
    },
    {
      "test": "(С++Builder) Основним методом, що виконує відкриття будь-якого стандартного діалогу, є",
      "variant_1": [
        " Execute()",
        "True"
      ],
      "variant_2": [
        "OpenDialog()",
        "False"
      ],
      "variant_3": [
        "ShowDialog()",
        "False"
      ]
    },
    {
      "test": "(С++Builder) Елементи списку ListBox зберігаються у властивості",
      "variant_1": [
        " Items",
        "True"
      ],
      "variant_2": [
        "Lines",
        "False"
      ],
      "variant_3": [
        "Strings",
        "False"
      ]
    },
    {
      "test": "(С++Builder) Кількість елементів списку ListBox визначається властивістю",
      "variant_1": [
        " Count",
        "True"
      ],
      "variant_2": [
        "CountItems",
        "False"
      ],
      "variant_3": [
        "ItemsCount",
        "False"
      ]
    },
    {
      "test": "(С++Builder) Значенням властивості Style списку ComboBox, яке дозволяє лише обирати елементи зі списку і забороняє введення даних в полі редагування, є",
      "variant_1": [
        " csDropDownList",
        "True"
      ],
      "variant_2": [
        "csDropDown",
        "False"
      ],
      "variant_3": [
        "csSimple",
        "False"
      ]
    },
    {
      "test": "(С++Builder) Кількість рядків та стовпців таблиці StringGrid, зберігається в її властивостях",
      "variant_1": [
        "CountRow і CountCol",
        "False"
      ],
      "variant_2": [
        " RowCount і ColCount",
        "True"
      ],
      "variant_3": [
        "Row і Col",
        "False"
      ]
    },
    {
      "test": "(С++Builder) Індекси виділеної клітинки таблиці StringGrid, зберігається в її властивостях",
      "variant_1": [
        " Row і Col",
        "True"
      ],
      "variant_2": [
        "Rows і Cols",
        "False"
      ],
      "variant_3": [
        "RowIndex і ColIndex",
        "False"
      ]
    },
    {
      "test": "(С++Builder) Можливість змінювати за допомогою миші розміри стовпців та рядків таблиці StringGrid надається за допомогою властивості",
      "variant_1": [
        " Options",
        "True"
      ],
      "variant_2": [
        "Resize",
        "False"
      ],
      "variant_3": [
        "Move",
        "False"
      ]
    },
    {
      "test": "(С#, WinForms) Заголовок форми визначається її властивістю",
      "variant_1": [
        " Text",
        "True"
      ],
      "variant_2": [
        "Caption",
        "False"
      ],
      "variant_3": [
        "Title",
        "False"
      ]
    },
    {
      "test": "(С#, WinForms) Фоновий колір форми визначається її властивістю",
      "variant_1": [
        "Color",
        "False"
      ],
      "variant_2": [
        " BackColor",
        "True"
      ],
      "variant_3": [
        "ForeColor",
        "False"
      ]
    },
    {
      "test": "(С#, WinForms) Положення форми по відношенню до верхнього лівого кута екрану визначається її властивістю",
      "variant_1": [
        " Location",
        "True"
      ],
      "variant_2": [
        "Position",
        "False"
      ],
      "variant_3": [
        "TopLeft",
        "False"
      ]
    },
    {
      "test": "(С#, WinForms) Розміри форми  визначається її властивістю",
      "variant_1": [
        "Location",
        "False"
      ],
      "variant_2": [
        " Size",
        "True"
      ],
      "variant_3": [
        "Position",
        "False"
      ]
    },
    {
      "test": "(С#, WinForms) Колір шрифту  визначається її властивістю",
      "variant_1": [
        "BackColor",
        "False"
      ],
      "variant_2": [
        "FontColor",
        "False"
      ],
      "variant_3": [
        " ForeColor",
        "True"
      ]
    },
    {
      "test": "(С#, WinForms) Параметр sender обробника події",
      "variant_1": [
        " визначає об’єкт, що її викликав",
        "True"
      ],
      "variant_2": [
        "визначає повідомлення про те, що подія відбулася",
        "False"
      ],
      "variant_3": [
        "зберігає інформацію про подію",
        "False"
      ]
    },
    {
      "test": "(С#, WinForms) Забезпечити відображення повідомлення в процесі роботи проекту можна таким чином:",
      "variant_1": [
        "ShowMessage (“Повідомлення”);",
        "False"
      ],
      "variant_2": [
        " MessageBox.Show(“Повідомлення”);",
        "True"
      ],
      "variant_3": [
        "Message(“Повідомлення”);",
        "False"
      ]
    },
    {
      "test": "(С#, WinForms) Список компонентів, що розташовані в контейнері, міститься в його властивості",
      "variant_1": [
        "List",
        "False"
      ],
      "variant_2": [
        " Controls",
        "True"
      ],
      "variant_3": [
        "Items",
        "False"
      ]
    },
    {
      "test": "(С#, WinForms) Програмно додати компонент в контейнер",
      "variant_1": [
        "не можливо",
        "False"
      ],
      "variant_2": [
        "можна за допомогою методу Add класу контейнера",
        "False"
      ],
      "variant_3": [
        " можна за допомогою методу Add властивості Controls класу контейнера",
        "True"
      ]
    },
    {
      "test": "(С#, WinForms) Програмно видалити компонент з контейнера за допомогою методу  його властивості Controls",
      "variant_1": [
        " Remove",
        "True"
      ],
      "variant_2": [
        "Delete",
        "False"
      ],
      "variant_3": [
        "Erase",
        "False"
      ]
    },
    {
      "test": "(С#, WinForms) Контейнером з декількома вкладками (сторінками) є компонент",
      "variant_1": [
        " TabControl",
        "True"
      ],
      "variant_2": [
        "PageControl",
        "False"
      ],
      "variant_3": [
        "Blocknote",
        "False"
      ]
    },
    {
      "test": "(С#, WinForms) Графічне зображення фону кнопки Button визначається за допомогою властивості",
      "variant_1": [
        "Image",
        "False"
      ],
      "variant_2": [
        " BackgroundImage",
        "True"
      ],
      "variant_3": [
        "Picture",
        "False"
      ]
    },
    {
      "test": "(С#, WinForms) Для введення і редагування тексту призначені текстові поля – елементи",
      "variant_1": [
        " TextBox",
        "True"
      ],
      "variant_2": [
        "Edit",
        "False"
      ],
      "variant_3": [
        "Label",
        "False"
      ]
    },
    {
      "test": "(С#, WinForms) Для введення і редагування багаторядкового тексту в компоненті TextBox потрібно встановити значення true властивості",
      "variant_1": [
        "Lines",
        "False"
      ],
      "variant_2": [
        " Multiline",
        "True"
      ],
      "variant_3": [
        "ReadOnly",
        "False"
      ]
    },
    {
      "test": "(С#, WinForms) При зміні стану перемикачів CheckBox і RadioButton генерується подія",
      "variant_1": [
        " CheckedChanged",
        "True"
      ],
      "variant_2": [
        "SelectedChanged",
        "False"
      ],
      "variant_3": [
        "Activate",
        "False"
      ]
    },
    {
      "test": "(С#, WinForms) Видалення елементів списку ListBox здійснюється за допомогою його методів",
      "variant_1": [
        " Remove",
        "True"
      ],
      "variant_2": [
        " RemoveAt",
        "True"
      ],
      "variant_3": [
        "Delete",
        "False"
      ]
    },
    {
      "test": "(С#, WinForms) При зміні виділеного елемента в ListBox виникає подія",
      "variant_1": [
        "IndexChanged",
        "False"
      ],
      "variant_2": [
        " SelectedIndexChanged",
        "True"
      ],
      "variant_3": [
        "ItemChanged",
        "False"
      ]
    },
    {
      "test": "(С#, WinForms) Всі обрані елементи списку CheckListBox містяться у властивості",
      "variant_1": [
        " SelectedItems",
        "True"
      ],
      "variant_2": [
        "SelectedIndeces",
        "False"
      ],
      "variant_3": [
        "CheckedItems",
        "False"
      ]
    },
    {
      "test": "(С#, WinForms) Індекси всіх обраних елементів списку CheckListBox містяться у властивості",
      "variant_1": [
        " SelectedIndeces",
        "True"
      ],
      "variant_2": [
        "CheckedIndeces",
        "False"
      ],
      "variant_3": [
        "SelectedItems",
        "False"
      ]
    },
    {
      "test": "(С#, WinForms) Можливість вибору числа з визначеного діапазону забезпечується за допомогою компоненту",
      "variant_1": [
        "SpinEdit",
        "False"
      ],
      "variant_2": [
        "UpDown",
        "False"
      ],
      "variant_3": [
        " NumericUpDown",
        "True"
      ]
    },
    {
      "test": "(Java) Пакет awt – це набір класів, які реалізують",
      "variant_1": [
        " функції та відображення елементів GUI",
        "True"
      ],
      "variant_2": [
        "стандартні функції роботи з датою і часом",
        "False"
      ],
      "variant_3": [
        "стандартні функції роботи з файлами і папками",
        "False"
      ]
    },
    {
      "test": "(Java, пакет awt) Практично всі класи візуальних компонентів є нащадками абстрактного класу",
      "variant_1": [
        "Grafics",
        "False"
      ],
      "variant_2": [
        "Object",
        "False"
      ],
      "variant_3": [
        " Component",
        "True"
      ]
    },
    {
      "test": "(Java, пакет awt) Прямими нащадками класу Container є",
      "variant_1": [
        " Panel",
        "True"
      ],
      "variant_2": [
        " Window",
        "True"
      ],
      "variant_3": [
        "Frame",
        "False"
      ]
    },
    {
      "test": "(Java, пакет awt) Клас Applet успадкований від класу",
      "variant_1": [
        " Container",
        "True"
      ],
      "variant_2": [
        " Panel",
        "True"
      ],
      "variant_3": [
        "Window",
        "False"
      ]
    },
    {
      "test": "(Java, пакет awt) Клас Frame – це",
      "variant_1": [
        "порожній квадрат, на якому можна виконувати малювання",
        "False"
      ],
      "variant_2": [
        "контейнер для розташування інших компонентів",
        "False"
      ],
      "variant_3": [
        " стандартне вікно Windows",
        "True"
      ]
    },
    {
      "test": "(Java, пакет awt) Клас Canvas – це",
      "variant_1": [
        " порожній квадрат, на якому можна виконувати малювання",
        "True"
      ],
      "variant_2": [
        "поле для введення багаторядкового тексту",
        "False"
      ],
      "variant_3": [
        "контейнер для розташування інших компонентів",
        "False"
      ]
    },
    {
      "test": "(Java, пакет awt) Клас TextArea – це",
      "variant_1": [
        "кнопка",
        "False"
      ],
      "variant_2": [
        "надпис",
        "False"
      ],
      "variant_3": [
        " поле для введення багаторядкового тексту",
        "True"
      ]
    },
    {
      "test": "Термін «програмна інженерія» вперше було використано у:",
      "variant_1": [
        "1969 році",
        "False"
      ],
      "variant_2": [
        "1970 році",
        "False"
      ],
      "variant_3": [
        "1968 році",
        "True"
      ]
    },
    {
      "test": "Основа програмної інженерії – це:",
      "variant_1": [
        " ядро знань SWEBOK",
        "True"
      ],
      "variant_2": [
        "комітет фахівців IEEI",
        "False"
      ],
      "variant_3": [
        "Міжнародний стандарт ISO/IEC 122006",
        "False"
      ]
    },
    {
      "test": "Програмна інженерія – це:",
      "variant_1": [
        "сукупність технічних засобів, що забезпечують функціонування програмного забезпечення",
        "False"
      ],
      "variant_2": [
        " сукупність інженерних методів та засобів створення програмного забезпечення",
        "True"
      ],
      "variant_3": [
        "колектив інженерів-програмістів, які створюють програмного забезпечення",
        "False"
      ]
    },
    {
      "test": "Теоретичний фундамент програмної інженерії складається з:",
      "variant_1": [
        " теорії алгоритмів, керування, математичної логіки",
        "True"
      ],
      "variant_2": [
        "правознавства, математичного аналізу",
        "False"
      ],
      "variant_3": [
        "теорії ймовірностей, патентознавства",
        "False"
      ]
    },
    {
      "test": "Програмна інженерія як наукова дисципліна",
      "variant_1": [
        " охоплює теоретичні, формальні методи та відповідні засоби побудови складних програм",
        "True"
      ],
      "variant_2": [
        "сукупність прийомів виконання діяльності, пов’язаної з виготовленням програмного продукту",
        "False"
      ],
      "variant_3": [
        "вивчає практичний досвід розробки комп’ютерних програм",
        "False"
      ]
    },
    {
      "test": "Теорія програмування – це:",
      "variant_1": [
        " сукупність методів, мов і засобів опису та проектування цільових об’єктів, а також методів їхнього доведення, верифікації і тестування",
        "True"
      ],
      "variant_2": [
        "унікальний інтегрований комплекс взаємозалежних заходів, орієнтованих на досягнення цілей",
        "False"
      ],
      "variant_3": [
        "сукупність взаємопов’язаних цільових об’єктів різних типів",
        "False"
      ]
    },
    {
      "test": "Програмна інженерія як інженерна дисципліна – це:",
      "variant_1": [
        "сукупність алгоритмів, пов’язаних з розробкою програмної документації",
        "False"
      ],
      "variant_2": [
        " сукупність прийомів виконання діяльності, пов’язаних з виготовленням програмного продукту",
        "True"
      ],
      "variant_3": [
        "описи практичних методів розробки програмних продуктів",
        "False"
      ]
    },
    {
      "test": "Механізм доступу до баз даних – це",
      "variant_1": [
        "набір компонентів середовища програмування, який зв’язує програмний проект з базою даних",
        "False"
      ],
      "variant_2": [
        "в деякій мірі універсальний прошарок, який зв’язує програмний проект з базою даних",
        "True"
      ],
      "variant_3": [
        "система керування базою даних",
        "False"
      ]
    },
    {
      "test": "Механізм доступу до баз даних",
      "variant_1": [
        "реалізує інтерфейс доступу до даних на логічному рівні, не залежний від обраного типу бази даних",
        "True"
      ],
      "variant_2": [
        "реалізує інтерфейс доступу до даних на логічному рівні, залежний від обраного типу бази даних",
        "False"
      ],
      "variant_3": [
        "виконує функції отримання даних з бази (з урахуванням особливостей збереження та правил обміну)",
        "True"
      ]
    },
    {
      "test": "Провайдером даних у термінології ADO.NET є:",
      "variant_1": [
        "набір стандартних візуальних компонентів IDE",
        "False"
      ],
      "variant_2": [
        "набір утиліт операційної системи",
        "False"
      ],
      "variant_3": [
        "набір класів, що виконують функції посередника при взаємодії програми і бази даних та ефективно реалізують основні операції роботи з її таблицями",
        "True"
      ]
    },
    {
      "test": "До провайдерів даних, що постачаються з .NET Framework належать:",
      "variant_1": [
        "SQL Server .NET Data Provider",
        "True"
      ],
      "variant_2": [
        "Access Data Provider",
        "False"
      ],
      "variant_3": [
        "OleDb .NET Data Provider",
        "True"
      ]
    },
    {
      "test": "Будь-який провайдер ADO.NET включає власні реалізації таких універсальних класів:",
      "variant_1": [
        "DataSet",
        "False"
      ],
      "variant_2": [
        "Connection",
        "True"
      ],
      "variant_3": [
        "DataAdapter",
        "True"
      ]
    },
    {
      "test": "З’єднання з БД за технологією ADO.NET виконується з використанням класу:",
      "variant_1": [
        "Command",
        "False"
      ],
      "variant_2": [
        "Connection",
        "True"
      ],
      "variant_3": [
        "DataAdapter",
        "False"
      ]
    },
    {
      "test": "Клас  Command за технологією ADO.NET забезпечує обмін даними між проектом і БД:",
      "variant_1": [
        "лише в приєднаному режимі",
        "True"
      ],
      "variant_2": [
        "лише у від’єднаному режимі",
        "False"
      ],
      "variant_3": [
        "у будь-якому режимі",
        "False"
      ]
    },
    {
      "test": "Клас  Command за технологією ADO.NET забезпечує обмін даними між проектом і БД:",
      "variant_1": [
        "лише в приєднаному режимі",
        "True"
      ],
      "variant_2": [
        "лише у від’єднаному режимі",
        "False"
      ],
      "variant_3": [
        "у будь-якому режимі",
        "False"
      ]
    },
    {
      "test": "Клас DataAdapter за технологією ADO.NET:",
      "variant_1": [
        "здійснює з’єднання з БД за технологією ADO.NET",
        "False"
      ],
      "variant_2": [
        "виконує функції посередника у взаємодії між БД і об'єктом DataSet",
        "True"
      ],
      "variant_3": [
        "забезпечує обмін даними між проектом і БД в приєднаному режимі",
        "False"
      ]
    },
    {
      "test": "В ADO.NET рядок підключення до БД ConnectionString є :",
      "variant_1": [
        "властивістю класу OleDbConnection",
        "True"
      ],
      "variant_2": [
        "властивістю класу OleDbCommand",
        "False"
      ],
      "variant_3": [
        "методом класу OleDbConnection",
        "False"
      ]
    },
    {
      "test": "В ADO.NET підключення до БД здійснюється методом класу OleDbConnection",
      "variant_1": [
        "CreateCommand()",
        "False"
      ],
      "variant_2": [
        "BeginDBTransaction()",
        "False"
      ],
      "variant_3": [
        "Open()",
        "True"
      ]
    },
    {
      "test": "ADO.NET властивістю класу OleDbConnection, що визначає стан підключення до БД є:",
      "variant_1": [
        "DataSource",
        "False"
      ],
      "variant_2": [
        "State",
        "True"
      ],
      "variant_3": [
        "ConnectionTimeout",
        "False"
      ]
    },
    {
      "test": "ADO.NET виконання команд на сервері БД виконується об’єктом класу",
      "variant_1": [
        "OleDbDataReader",
        "False"
      ],
      "variant_2": [
        "OleDbCommand",
        "True"
      ],
      "variant_3": [
        "OleDbConnection",
        "False"
      ]
    },
    {
      "test": "В ADO.NET SQL-запит на виконання команди в БД на сервері міститься",
      "variant_1": [
        "у властивості CommandText класу OleDbCommand",
        "True"
      ],
      "variant_2": [
        "у властивості Command класу OleDbCommand",
        "False"
      ],
      "variant_3": [
        "у властивості Text класу OleDbCommand",
        "False"
      ]
    },
    {
      "test": "ADO.NET CreateCommand(), що створює об’єкт команди є методом класу",
      "variant_1": [
        "OleDbCommand",
        "True"
      ],
      "variant_2": [
        "OleDbDataReader",
        "False"
      ],
      "variant_3": [
        "OleDbConnection",
        "False"
      ]
    },
    {
      "test": "В ADO.NET один результат виконання SQL-запиту в БД повертається методом",
      "variant_1": [
        "ExecuteOnlyOne() класу OleDbCommand",
        "False"
      ],
      "variant_2": [
        "ExecuteScalar() класу OleDbCommand",
        "True"
      ],
      "variant_3": [
        "ExecuteScalar() класу OleDbConnection",
        "False"
      ]
    },
    {
      "test": "Класи ADO.NET можна умовно розділити на такі категорії:",
      "variant_1": [
        "disconnected",
        "True"
      ],
      "variant_2": [
        "connected",
        "True"
      ],
      "variant_3": [
        "virtual",
        "False"
      ]
    },
    {
      "test": "В ADO.NET закриття з’єднання до БД здійснюється методом класу OleDbConnection",
      "variant_1": [
        "Finish ()",
        "False"
      ],
      "variant_2": [
        "End ()",
        "False"
      ],
      "variant_3": [
        "Close()",
        "True"
      ]
    },
    {
      "test": "В ADO.NET результат виконання методу ExecuteScalar() класу OleDbCommand має тип даних",
      "variant_1": [
        "Char[]",
        "False"
      ],
      "variant_2": [
        "Object",
        "True"
      ],
      "variant_3": [
        "String",
        "False"
      ]
    },
    {
      "test": "В ADO.NET запити, що повертають набори даних, виконуються за допомогою методу",
      "variant_1": [
        "ExecuteReader() класу OleDbCommand при відкритому з’єднанні з БД",
        "True"
      ],
      "variant_2": [
        "ExecuteReader() класу OleDbCommand при закритому з’єднанні з БД",
        "False"
      ],
      "variant_3": [
        "ExecuteReader() класу OleDbDataReader при відкритому з’єднанні з БД",
        "False"
      ]
    },
    {
      "test": "В ADO.NET результатом виконання методу ExecuteReader() класу OleDbCommand є:",
      "variant_1": [
        "об’єкт класу OleDbCommand",
        "False"
      ],
      "variant_2": [
        "стан підключення до БД",
        "False"
      ],
      "variant_3": [
        "екземпляр класу OleDbDataReader",
        "True"
      ]
    },
    {
      "test": "В ADO.NET метод Read() класу OleDbDataReader",
      "variant_1": [
        "повертає значення логічного типу",
        "True"
      ],
      "variant_2": [
        "повертає значення рядкового типу",
        "False"
      ],
      "variant_3": [
        "повертає рядок даних результату виконання SQL-запиту",
        "False"
      ]
    },
    {
      "test": "В ADO.NET об’єкт reader класу OleDbDataReader повертає значення поля з другим порядковим номером  набору даних таким чином:",
      "variant_1": [
        "reader.GetValue[1]",
        "False"
      ],
      "variant_2": [
        "reader.GetValue{2}",
        "False"
      ],
      "variant_3": [
        "reader.GetValue(1)",
        "True"
      ]
    },
    {
      "test": "В ADO.NET об’єкт reader класу OleDbDataReader повертає значення поля \"Країна\" набору даних таким чином:",
      "variant_1": [
        "reader (\"Країна\")",
        "False"
      ],
      "variant_2": [
        "reader [\"Країна\"]",
        "True"
      ],
      "variant_3": [
        "reader.Країна",
        "False"
      ]
    },
    {
      "test": "В ADO.NET об’єкт reader класу OleDbDataReader повертає індекс поля \"Країна\" набору даних таким чином:",
      "variant_1": [
        "reader.GetOrdinal (\"Країна \")",
        "True"
      ],
      "variant_2": [
        "reader.Index (\"Країна \")",
        "False"
      ],
      "variant_3": [
        "reader.IndexOf (\"Країна \")",
        "False"
      ]
    },
    {
      "test": "В ADO.NET параметри SQL-запиту об’єкту команд класу OleDbCommand містяться в його властивості",
      "variant_1": [
        "Values",
        "False"
      ],
      "variant_2": [
        "Parameters",
        "True"
      ],
      "variant_3": [
        "Items",
        "False"
      ]
    },
    {
      "test": "В ADO.NET параметри в SQL-запиті об’єкту команд класу OleDbCommand позначаються таким чином:",
      "variant_1": [
        "?",
        "True"
      ],
      "variant_2": [
        "#",
        "False"
      ],
      "variant_3": [
        "@<ім’я параметру>",
        "True"
      ]
    },
    {
      "test": "В ADO.NET значення i-го параметру SQL-запиту об’єкту command команд класу OleDbCommand задаються таким чином:",
      "variant_1": [
        "Command.Parameters.Items[i] = <значення>",
        "False"
      ],
      "variant_2": [
        "command.Parameters[i].Value = <значення>",
        "True"
      ],
      "variant_3": [
        "command.Value[i] = <значення>",
        "False"
      ]
    },
    {
      "test": "В ADO.NET клас OleDbDataAdapter реалізує всі необхідні методи для кешування даних у сховищі – об’єкті класу:",
      "variant_1": [
        "DataTable",
        "True"
      ],
      "variant_2": [
        "DataSet",
        "True"
      ],
      "variant_3": [
        "DataGridView",
        "False"
      ]
    },
    {
      "test": "В ADO.NET набір даних DataSet обробляється",
      "variant_1": [
        "при відкритому з’єднанні з БД",
        "False"
      ],
      "variant_2": [
        "при закритому з’єднанні з БД",
        "True"
      ],
      "variant_3": [
        "обидві попередні варіанти відповіді вірні",
        "False"
      ]
    },
    {
      "test": "В ADO.NET таблиці набору даних DataSet містяться в його властивості",
      "variant_1": [
        "Tables",
        "True"
      ],
      "variant_2": [
        "DataTables",
        "False"
      ],
      "variant_3": [
        "ADOTables",
        "False"
      ]
    },
    {
      "test": "В ADO.NET колекція зв’язків між таблицями набору даних DataSet зберігається в його властивості",
      "variant_1": [
        "ExpendedProperties",
        "False"
      ],
      "variant_2": [
        "Constraints",
        "False"
      ],
      "variant_3": [
        "Relations",
        "True"
      ]
    },
    {
      "test": "В ADO.NET колекція полів таблиці DataTable зберігається в її властивості",
      "variant_1": [
        "Columns",
        "True"
      ],
      "variant_2": [
        "Cols",
        "False"
      ],
      "variant_3": [
        "Rows",
        "False"
      ]
    },
    {
      "test": "В ADO.NET рядки (записи) таблиці DataTable зберігається в її властивості",
      "variant_1": [
        "Strings",
        "False"
      ],
      "variant_2": [
        "Rows",
        "True"
      ],
      "variant_3": [
        "Records",
        "False"
      ]
    },
    {
      "test": "В ADO.NET створення об’єкту нового рядку (запису) таблиці DataTable виконується її методом",
      "variant_1": [
        "AddRow()",
        "False"
      ],
      "variant_2": [
        "CreateRow()",
        "False"
      ],
      "variant_3": [
        "NewRow()",
        "True"
      ]
    },
    {
      "test": "В ADO.NET метод AcceptChanges() таблиці DataTable",
      "variant_1": [
        "приймає зміни в таблиці",
        "True"
      ],
      "variant_2": [
        "скасовує зміни в таблиці",
        "False"
      ],
      "variant_3": [
        "очищує таблицю",
        "False"
      ]
    },
    {
      "test": "В ADO.NET заголовок поля таблиці  DataTable визначається властивістю класу DataColumn",
      "variant_1": [
        "Caption",
        "True"
      ],
      "variant_2": [
        "ColumnName",
        "False"
      ],
      "variant_3": [
        "Name",
        "False"
      ]
    },
    {
      "test": "В ADO.NET позиція поля таблиці  DataTable визначається властивістю класу DataColumn",
      "variant_1": [
        "Index",
        "False"
      ],
      "variant_2": [
        "Ordinal",
        "True"
      ],
      "variant_3": [
        "IndexOf",
        "False"
      ]
    },
    {
      "test": "В ADO.NET тип поля таблиці  DataTable визначається властивістю класу DataColumn",
      "variant_1": [
        "TypeData",
        "False"
      ],
      "variant_2": [
        "Type",
        "False"
      ],
      "variant_3": [
        "DataType",
        "True"
      ]
    },
    {
      "test": "В ADO.NET створення об’єкту row класу DataRow для додавання рядку в таблицю table класу DataTable виконується таким чином:",
      "variant_1": [
        "DataRow row = new DataRow();",
        "False"
      ],
      "variant_2": [
        "DataRow row = table.CreateRow();",
        "False"
      ],
      "variant_3": [
        "DataRow row = table.NewRow();",
        "True"
      ]
    },
    {
      "test": "В ADO.NET звернення до поля \"Місто\", що має індекс 1, об’єкту row класу DataRow виконується таким чином:",
      "variant_1": [
        "row[\"Місто\"];",
        "True"
      ],
      "variant_2": [
        "row[1];",
        "True"
      ],
      "variant_3": [
        "row(1)",
        "False"
      ]
    },
    {
      "test": "В ADO.NET додавання об’єкту row класу DataRow в таблицю table класу DataTable виконується таким чином:",
      "variant_1": [
        "row.Add(table)",
        "False"
      ],
      "variant_2": [
        "table.Rows.Add(row)",
        "True"
      ],
      "variant_3": [
        "table.AddRow(row)",
        "False"
      ]
    },
    {
      "test": "В ADO.NET створення об’єкту row класу DataRow для редагування i-го рядку в таблиці table класу DataTable виконується таким чином:",
      "variant_1": [
        "DataRow row = table.Rows(i)",
        "False"
      ],
      "variant_2": [
        "DataRow row = table[i].Rows",
        "False"
      ],
      "variant_3": [
        "DataRow row = table.Rows[i]",
        "True"
      ]
    },
    {
      "test": "В ADO.NET пошук рядку таблиці DataTable за первинним ключем можна здійснити за допомогою методу класу DataRow",
      "variant_1": [
        "Find()",
        "True"
      ],
      "variant_2": [
        "Search()",
        "False"
      ],
      "variant_3": [
        "Locate()",
        "False"
      ]
    },
    {
      "test": "В ADO.NET рядок коду DataRow row = table.Rows.Find(20)",
      "variant_1": [
        "повертає об’єкт рядку таблиці table з ключовим полем 20, якщо він існує",
        "True"
      ],
      "variant_2": [
        "повертає null, якщо рядку з ключовим полем 20 в таблиці немає",
        "False"
      ],
      "variant_3": [
        "спричиняє виключну ситуація при відсутності рядку з ключовим полем 20",
        "False"
      ]
    },
    {
      "test": "В ADO.NET видалення i-го рядку з таблиці table класу DataTable можна виконати таким чином:",
      "variant_1": [
        "table.Rows.Remove(table.Rows[0])",
        "True"
      ],
      "variant_2": [
        "table.Rows.RemoveAt(0)",
        "True"
      ],
      "variant_3": [
        "table.Rows.RemoveAt(table.Rows[0])",
        "False"
      ]
    },
    {
      "test": "В ADO.NET видалення i-го рядку з таблиці table класу DataTable з використанням методу Delete() класу DataRow можна виконати таким чином:",
      "variant_1": [
        "table.Delete(0)",
        "False"
      ],
      "variant_2": [
        "table.Delete(Rows[0])",
        "False"
      ],
      "variant_3": [
        "table.Rows[0].Delete()",
        "True"
      ]
    },
    {
      "test": "В ADO.NET фільтр даних у таблиці  можна виконати за допомогою методу класу DataTable",
      "variant_1": [
        "Filtr",
        "False"
      ],
      "variant_2": [
        "Select",
        "True"
      ],
      "variant_3": [
        "Find",
        "False"
      ]
    },
    {
      "test": "В ADO.NET параметрами методу Select класу DataTable є",
      "variant_1": [
        "SQL-запит на вибірку з заданими умовами",
        "True"
      ],
      "variant_2": [
        "об’єкт класу DataTable",
        "False"
      ],
      "variant_3": [
        "індекс стовбця (поля) таблиці",
        "False"
      ]
    },
    {
      "test": "В ADO.NET встановлення зв’язку між таблицями БД може здійснюватися з використанням:",
      "variant_1": [
        "запиту на вибірку з двох таблиць",
        "True"
      ],
      "variant_2": [
        "об’єкту класу DataRelation",
        "True"
      ],
      "variant_3": [
        "об’єкту класу DataSet",
        "False"
      ]
    },
    {
      "test": "В ADO.NET конструктор класу DataRelation",
      "variant_1": [
        "не має параметрів",
        "False"
      ],
      "variant_2": [
        "має один параметр – найменування зв’язку",
        "False"
      ],
      "variant_3": [
        "має три параметри – найменування зв’язку, об’єкти полів зв’язку між таблицями",
        "True"
      ]
    },
    {
      "test": "В ADO.NET об’єкт класу DataRelation додається в колекцію властивості Relation набору даних – об’єкту DataSet методом",
      "variant_1": [
        "Add",
        "True"
      ],
      "variant_2": [
        "Insert",
        "False"
      ],
      "variant_3": [
        "Update",
        "False"
      ]
    },
    {
      "test": "В ADO.NET метод GetChildRows() властивості (класу) Rows таблиці DataTable призначений для:",
      "variant_1": [
        "отримання записів дочірньої (підлеглої) таблиці, що відповідають заданому рядку батьківської (головної) таблиці",
        "True"
      ],
      "variant_2": [
        "отримання запису батьківської (головної) таблиці для заданого рядку дочірньої таблиці",
        "False"
      ],
      "variant_3": [
        "встановлення зв’язку між головною і підлеглою таблицями",
        "False"
      ]
    },
    {
      "test": "В ADO.NET метод GetParentRow() властивості (класу) Rows таблиці DataTable призначений для:",
      "variant_1": [
        "скасування зв’язку між головною і підлеглою таблицями",
        "False"
      ],
      "variant_2": [
        "отримання записів дочірньої (підлеглої) таблиці, що відповідають заданому рядку батьківської (головної) таблиці",
        "False"
      ],
      "variant_3": [
        " запису батьківської (головної) таблиці для заданого рядку дочірньої таблиці",
        "True"
      ]
    },
    {
      "test": "В ADO.NET метод GetChildRows() властивості (класу) Rows таблиці DataTable",
      "variant_1": [
        "не має параметрів",
        "False"
      ],
      "variant_2": [
        "має один параметр – найменування зв’язку, визначеного при створенні об’єкту DataRelation",
        "True"
      ],
      "variant_3": [
        "має два параметри – імена головної і підлеглої таблиць DataTable",
        "False"
      ]
    },
    {
      "test": "В ADO.NET метод GetParentRow() властивості (класу) Rows таблиці DataTable",
      "variant_1": [
        "має один параметр – найменування зв’язку, визначеного при створенні об’єкту DataRelation",
        "True"
      ],
      "variant_2": [
        "має два параметри – імена головної і підлеглої таблиць DataTable",
        "False"
      ],
      "variant_3": [
        "не має параметрів",
        "False"
      ]
    },
    {
      "test": "В ADO.NET метод GetChildRows() властивості (класу) Rows таблиці DataTable повертає:",
      "variant_1": [
        "масив об’єктів класу DataRelation",
        "False"
      ],
      "variant_2": [
        "масив об’єктів класу DataRow",
        "True"
      ],
      "variant_3": [
        "один об’єкт класу DataRow",
        "False"
      ]
    },
    {
      "test": "В ADO.NET метод GetParentRow () властивості (класу) Rows таблиці DataTable повертає:",
      "variant_1": [
        "масив об’єктів класу DataRow",
        "False"
      ],
      "variant_2": [
        "об’єкт класу DataTable",
        "False"
      ],
      "variant_3": [
        "один об’єкт класу DataRow",
        "True"
      ]
    },
    {
      "test": "В System.Windows.Forms компонент BindingSource призначений для",
      "variant_1": [
        "завантаження даних з таблиць БД",
        "False"
      ],
      "variant_2": [
        "встановлення зв’язків між таблицями БД",
        "False"
      ],
      "variant_3": [
        "прив’язки бази даних до форми проекту",
        "True"
      ]
    },
    {
      "test": "В System.Windows.Forms властивість DataSource компонента BindingSource може містити ім’я",
      "variant_1": [
        "набору даних класу DataSet",
        "True"
      ],
      "variant_2": [
        "іншого об’єкту DataSource",
        "True"
      ],
      "variant_3": [
        "об’єкту класу DataAdapter",
        "False"
      ]
    },
    {
      "test": "В ADO.NET після завершення діалогу «Мастер настройки источника данных»",
      "variant_1": [
        "на формі проекту відображається об’єкт класу  DataSet",
        "False"
      ],
      "variant_2": [
        "на додатковій панелі під формою проекту відображається об’єкт класу  DataAdapter",
        "False"
      ],
      "variant_3": [
        "на додатковій панелі під формою проекту відображається об’єкт класу  DataSet",
        "True"
      ]
    },
    {
      "test": "Відображення вмісту таблиць БД у вигляді сітки на формі проекту здійснюється за допомогою компоненту System.Windows.Forms",
      "variant_1": [
        "StringGrid",
        "False"
      ],
      "variant_2": [
        "DataGridView",
        "True"
      ],
      "variant_3": [
        "ListView",
        "False"
      ]
    },
    {
      "test": "Візуальні компоненти System.Windows.Forms для відображення даних таблиць БД використовують властивість:",
      "variant_1": [
        "DataSource",
        "True"
      ],
      "variant_2": [
        "DataMember",
        "False"
      ],
      "variant_3": [
        "Columns",
        "False"
      ]
    },
    {
      "test": "В процесі проектування зв’язку між таблицею БД та компонентом-сіткою System.Windows.Forms (DataGridView) створюються об’єкти класів",
      "variant_1": [
        "BindingSource",
        "True"
      ],
      "variant_2": [
        "DataAdapter",
        "True"
      ],
      "variant_3": [
        "DataTable",
        "False"
      ]
    },
    {
      "test": "Компонент BindingSource є класом бібліотеки",
      "variant_1": [
        "ADO.NET",
        "False"
      ],
      "variant_2": [
        "System.Windows.Forms",
        "True"
      ],
      "variant_3": [
        "VCL",
        "False"
      ]
    },
    {
      "test": "Структуру БД, приєднану до проекту за технологією ADO.NET шляхом проектування, можна побачити в вікні IDE Visual Studio",
      "variant_1": [
        "Обозреватель серверов",
        "True"
      ],
      "variant_2": [
        "Панель элементов",
        "False"
      ],
      "variant_3": [
        "Обозреватель решений",
        "False"
      ]
    },
    {
      "test": "Ім’я набору даних (об’єкту класу ADO.NET) за замовчуванням встановлюється за таким правилом:",
      "variant_1": [
        "ім’я БД + DataTable",
        "False"
      ],
      "variant_2": [
        "ім’я БД + DataAdapter",
        "False"
      ],
      "variant_3": [
        "ім’я БД + DataSet",
        "True"
      ]
    },
    {
      "test": "Ім’я набору даних (об’єкту класу ADO.NET)",
      "variant_1": [
        "можна змінити в процесі проектування у вікні «Выбор объектов базы данных»",
        "True"
      ],
      "variant_2": [
        "можна змінити у вікні «Свойства» IDE Visual Studio",
        "True"
      ],
      "variant_3": [
        "не можна змінювати",
        "False"
      ]
    },
    {
      "test": "В System.Windows.Forms компонент BindingNavigator забезпечує:",
      "variant_1": [
        "навігацію по записах таблиці БД, дозволяє додавати та видаляти",
        "True"
      ],
      "variant_2": [
        "додавання, видалення даних з таблиць БД",
        "True"
      ],
      "variant_3": [
        "сортування та фільтр даних у таблицях БД",
        "False"
      ]
    },
    {
      "test": "В System.Windows.Forms контролювати формат даних, введених користувачем з клавіатури в текстове поле TextBox можна за допомогою обробника події",
      "variant_1": [
        "TextChanged",
        "False"
      ],
      "variant_2": [
        "Enter",
        "False"
      ],
      "variant_3": [
        "KeyPress",
        "True"
      ]
    },
    {
      "test": "Програмна інженерія як виробнича дисципліна вивчає:",
      "variant_1": [
        " практичне виготовлення комп’ютерних програм, систем та інструментів на основі теоретичних та інженерних методів",
        "True"
      ],
      "variant_2": [
        "виготовлення документації для розробки і впровадження програмного забезпечення",
        "False"
      ],
      "variant_3": [
        "сукупність прийомів, пов’язаних з алгоритмами розробки програмного забезпечення",
        "False"
      ]
    },
    {
      "test": "Програмна інженерія як дисципліна керування",
      "variant_1": [
        " вивчає практичне виготовлення комп’ютерних програм, систем та інструментів",
        "True"
      ],
      "variant_2": [
        "є сукупністю прийомів виконання діяльності, пов’язаних з виготовленням програмного продукту",
        "False"
      ],
      "variant_3": [
        "базується на класичній теорії керування системами, сучасного менеджменту проекту PMBOK",
        "False"
      ]
    },
    {
      "test": "Програмна інженерія як економічна дисципліна – це:",
      "variant_1": [
        " теорія і практична оцінка вартісних, часових і експертних показників щодо складання контрактів на створення програмних продуктів",
        "True"
      ],
      "variant_2": [
        "практика вартісних показників оцінки доцільності розробки програмних продуктів",
        "False"
      ],
      "variant_3": [
        "методи оцінки показників якості програмного забезпечення",
        "False"
      ]
    },
    {
      "test": "Процес розробки програмного забезпечення автоматизованих інформаційних систем – це:",
      "variant_1": [
        " складна, трудомістка та довгострокова робота, яка вимагає високої кваліфікації спеціалістів, проектувальників та програмістів",
        "True"
      ],
      "variant_2": [
        "рутинна робота, яка не вимагає високої кваліфікації розробників ПЗ",
        "False"
      ],
      "variant_3": [
        "складна робота, яка вимагає високої кваліфікації користувачів ПЗ",
        "False"
      ]
    },
    {
      "test": "Життєвий цикл програмного забезпечення – це:",
      "variant_1": [
        "період часу, який починається з моменту задуму ПЗ до кінця етапу розробки",
        "False"
      ],
      "variant_2": [
        " період часу, який починається з моменту прийняття рішення про необхідність створення ПЗ і закінчується в момент його вилучення з експлуатації",
        "True"
      ],
      "variant_3": [
        "період часу, який починається з моменту введення ПЗ в експлуатацію",
        "False"
      ]
    },
    {
      "test": "Процес життєвого циклу програмного забезпечення – це:",
      "variant_1": [
        " сукупність взаємопов’язаних дій, які перетворюють вхідні дані у вихідні",
        "True"
      ],
      "variant_2": [
        "сукупність алгоритмів, які перетворюють вхідні дані у вихідні",
        "False"
      ],
      "variant_3": [
        "сукупність процедур для розробки ПЗ",
        "False"
      ]
    },
    {
      "test": "Процеси життєвого циклу програмного забезпечення поділяється на:",
      "variant_1": [
        "4 групи",
        "False"
      ],
      "variant_2": [
        "9 груп",
        "False"
      ],
      "variant_3": [
        " 3 групи",
        "True"
      ]
    },
    {
      "test": "Групами процесів життєвого циклу програмного забезпечення є:",
      "variant_1": [
        "основні, супроводжувальні, навчальні",
        "False"
      ],
      "variant_2": [
        "організаційні, виконавчі, впроваджувальні",
        "False"
      ],
      "variant_3": [
        " основні, допоміжні, організаційні",
        "True"
      ]
    },
    {
      "test": "Процес «придбання» життєвого циклу програмного забезпечення належить до групи:",
      "variant_1": [
        " основних",
        "True"
      ],
      "variant_2": [
        "допоміжних",
        "False"
      ],
      "variant_3": [
        "організаційних",
        "False"
      ]
    },
    {
      "test": "Процеси «управління» та «навчання» життєвого циклу програмного забезпечення належить до групи:",
      "variant_1": [
        "супроводжувальних",
        "False"
      ],
      "variant_2": [
        " організаційних",
        "True"
      ],
      "variant_3": [
        "основних",
        "False"
      ]
    },
    {
      "test": "До допоміжних процесів життєвого циклу програмного забезпечення належать такі:",
      "variant_1": [
        " документування, верифікація, атестація",
        "True"
      ],
      "variant_2": [
        "розробка, аудит, управління",
        "False"
      ],
      "variant_3": [
        "поставка, придбання, розробка",
        "False"
      ]
    },
    {
      "test": "До організаційних процесів життєвого циклу програмного забезпечення належать такі:",
      "variant_1": [
        "експлуатація, поставка, верифікація",
        "False"
      ],
      "variant_2": [
        " управління, вдосконалення, навчання",
        "True"
      ],
      "variant_3": [
        "аудит, атестація, верифікація",
        "False"
      ]
    },
    {
      "test": "Процес «придбання» життєвого циклу програмного забезпечення складається з таких дій та задач:",
      "variant_1": [
        "аналіз вимог до системи",
        "False"
      ],
      "variant_2": [
        " ініціювання придбання",
        "True"
      ],
      "variant_3": [
        "нагляд за діяльністю розробника",
        "False"
      ]
    },
    {
      "test": "Процес «поставки» » життєвого циклу програмного забезпечення складається з таких дій:",
      "variant_1": [
        " ініціювання поставки",
        "True"
      ],
      "variant_2": [
        "приймання програмного забезпечення",
        "False"
      ],
      "variant_3": [
        "підготовчі роботи",
        "False"
      ]
    },
    {
      "test": "Процес «розробки» життєвого циклу програмного забезпечення складається з таких дій:",
      "variant_1": [
        " інтеграція програмного забезпечення",
        "True"
      ],
      "variant_2": [
        "модернізація програмного забезпечення",
        "False"
      ],
      "variant_3": [
        "зняття програмного забезпечення з експлуатації",
        "False"
      ]
    },
    {
      "test": "Процес «супроводження» життєвого циклу програмного забезпечення складається з таких дій:",
      "variant_1": [
        " модифікація програмного забезпечення",
        "True"
      ],
      "variant_2": [
        "забезпечення якості програмного забезпечення",
        "False"
      ],
      "variant_3": [
        "аудит",
        "False"
      ]
    },
    {
      "test": "Процес «управління конфігурацією»  життєвого циклу програмного забезпечення складається з таких дій:",
      "variant_1": [
        "забезпечення якості програмного забезпечення",
        "False"
      ],
      "variant_2": [
        " контроль конфігурації програмного забезпечення",
        "True"
      ],
      "variant_3": [
        "управління якістю програмного забезпечення",
        "False"
      ]
    },
    {
      "test": "Модель життєвого циклу програмного забезпечення – це:",
      "variant_1": [
        " схема виконання робіт і задач у рамках процесів, що забезпечують розробку, експлуатацію і супровід програмного продукту",
        "True"
      ],
      "variant_2": [
        "математична формула, яка визначає залежність вхідних даних від вихідних",
        "False"
      ],
      "variant_3": [
        "схема структури розроблювальної системи",
        "False"
      ]
    },
    {
      "test": "Кваліфікаційна вимога – це:",
      "variant_1": [
        " набір критеріїв та умов відповідності програмного продукту специфікаціям і готовності до використання в умовах експлуатації",
        "True"
      ],
      "variant_2": [
        "набір критеріїв відповідності кваліфікації користувачів",
        "False"
      ],
      "variant_3": [
        "набір критеріїв відповідності кваліфікації розробників",
        "False"
      ]
    },
    {
      "test": "Модель життєвого циклу програмного забезпечення – це",
      "variant_1": [
        " структура, яка визначає послідовність виконання та взаємозв’язку  процесів, дій, задач протягом життєвого циклу",
        "True"
      ],
      "variant_2": [
        "макет об’єкту автоматизації",
        "False"
      ],
      "variant_3": [
        "математична формула, яка визначає залежність вхідних даних від вихідних",
        "False"
      ]
    },
    {
      "test": "Видами моделей життєвого циклу програмного забезпечення є:",
      "variant_1": [
        " каскадна, спіральна, інкрементна",
        "True"
      ],
      "variant_2": [
        "циліндрична, каскадна, спіральна",
        "False"
      ],
      "variant_3": [
        "математична, циліндрична, спіральна",
        "False"
      ]
    },
    {
      "test": "Каскадна модель життєвого циклу програмного забезпечення має такі недоліки:",
      "variant_1": [
        " реальні проекти дуже часто потребують відхилень від стандартної послідовності кроків",
        "True"
      ],
      "variant_2": [
        "труднощі контролю та керування терміном розробки",
        "False"
      ],
      "variant_3": [
        "відсутня достатня статистика ефективності моделі",
        "False"
      ]
    },
    {
      "test": "Спіральна модель життєвого циклу програмного забезпечення – це:",
      "variant_1": [
        "послідовність етапів, в якій перехід на наступний, ієрархічно нижче розташований рівень відбувається лише після повного завершення робіт на поточному етапі",
        "False"
      ],
      "variant_2": [
        " циклічний процес, який містить в своєму складі елементи аналізу ризику щодо успішності результатів розробки програмного забезпечення",
        "True"
      ],
      "variant_3": [
        "процес розробки програмного забезпечення, який базується на повторному використанні існуючих програмних компонентів",
        "False"
      ]
    },
    {
      "test": "Спіральна модель ЖЦПЗ має такі недоліки:",
      "variant_1": [
        "реальні проекти дуже часто потребують відхилень від стандартної послідовності кроків",
        "False"
      ],
      "variant_2": [
        "результати проекту доступні замовнику лише в кінці роботи",
        "False"
      ],
      "variant_3": [
        " труднощі контролю та керування терміном розробки",
        "True"
      ]
    },
    {
      "test": "RAD-модель життєвого циклу програмного забезпечення – це:",
      "variant_1": [
        "ітераційний процес проходження всіх етапів розробки програмного забезпечення, на кожному кроці якого здійснюється уточнення вимог до нього",
        "False"
      ],
      "variant_2": [
        " високошвидкісна адаптація лінійної послідовної моделі, в якій швидка розробка досягається за рахунок використання компонентно-орієнтованого конструювання",
        "True"
      ],
      "variant_3": [
        "циклічний процес, який містить в своєму складі елементи аналізу ризику щодо успішності результатів розробки програмного забезпечення",
        "False"
      ]
    },
    {
      "test": "Компонентно-орієнтована модель життєвого циклу програмного забезпечення – це:",
      "variant_1": [
        "послідовність етапів, в якій перехід на наступний, ієрархічно нижче розташований рівень відбувається лише після повного завершення робіт на поточному етапі",
        "False"
      ],
      "variant_2": [
        " процес розробки програмного забезпечення, який базується на повторному використанні існуючих програмних компонентів",
        "True"
      ],
      "variant_3": [
        "циклічний процес, який містить в своєму складі елементи аналізу ризику щодо успішності результатів розробки програмного забезпечення",
        "False"
      ]
    },
    {
      "test": "До переваг використання компонентно-орієнтованої моделі життєвого циклу програмного забезпечення належать:",
      "variant_1": [
        "використання моделювання для зменшення ризику і вдосконалення програмного продукту",
        "False"
      ],
      "variant_2": [
        " зменшення вартості програмної розробки на 70% та 30% терміну розробки програмного забезпечення",
        "True"
      ],
      "variant_3": [
        "включення системного підходу в ітераційну систему розробки",
        "False"
      ]
    },
    {
      "test": "До стратегій конструювання програмного забезпечення належать:",
      "variant_1": [
        " інкрементна",
        "True"
      ],
      "variant_2": [
        "логічна",
        "False"
      ],
      "variant_3": [
        "фізична",
        "False"
      ]
    },
    {
      "test": "Стратегією конструювання програмного забезпечення, що реалізує RAD-модель життєвого циклу програмного забезпечення, є:",
      "variant_1": [
        "водоспадна",
        "False"
      ],
      "variant_2": [
        " інкрементна",
        "True"
      ],
      "variant_3": [
        "еволюційна",
        "False"
      ]
    },
    {
      "test": "Якість процесів розробки програмного забезпечення визначається моделлю:",
      "variant_1": [
        " CMM",
        "True"
      ],
      "variant_2": [
        "RAD",
        "False"
      ],
      "variant_3": [
        "TO-BE",
        "False"
      ]
    },
    {
      "test": "Базовим поняттям СММ-моделі якості процесів розробки програмного забезпечення є:",
      "variant_1": [
        " зрілість компанії",
        "True"
      ],
      "variant_2": [
        "фаховий рівень компанії",
        "False"
      ],
      "variant_3": [
        "авторитет керівника компанії",
        "False"
      ]
    },
    {
      "test": "Зовнішній опис програмного продукту містить:",
      "variant_1": [
        "вимоги до процесів розробки програмного продукту",
        "False"
      ],
      "variant_2": [
        " всю інформацію, яку необхідно знати користувачу для застосування програмного продукту",
        "True"
      ],
      "variant_3": [
        "вимоги до рівня кваліфікації розробників програмного продукту",
        "False"
      ]
    },
    {
      "test": "Зовнішній опис програмного продукту є початковим документом для таких паралельних процесів:",
      "variant_1": [
        " розробки текстів (конструюванню та кодуванню) програм, що входять до складу програмного продукту",
        "True"
      ],
      "variant_2": [
        "розробки юридичних документів, що регулюють взаємовідносини замовника з розробником",
        "False"
      ],
      "variant_3": [
        "розробки суттєвої частини документації по застосуванню програмного продукту",
        "False"
      ]
    },
    {
      "test": "Вхідним документом для розробки зовнішнього опису програмного продукту є визначення",
      "variant_1": [
        "середовища програмування",
        "False"
      ],
      "variant_2": [
        " вимог до програмного продукту",
        "True"
      ],
      "variant_3": [
        "складу розробників",
        "False"
      ]
    },
    {
      "test": "Визначенню вимог передує процес системного аналізу, в якому з’ясується:",
      "variant_1": [
        "в якій операційній системі повинен працювати програмний продукт",
        "False"
      ],
      "variant_2": [
        "опис алгоритмів, що використовуватимуться програмним продуктом",
        "False"
      ],
      "variant_3": [
        " яким буде вплив програмного продукту на діяльність користувачів",
        "True"
      ]
    },
    {
      "test": "Спрощена версія програмного продукту називається:",
      "variant_1": [
        " прототипом",
        "True"
      ],
      "variant_2": [
        "моделлю",
        "False"
      ],
      "variant_3": [
        "шаблоном",
        "False"
      ]
    },
    {
      "test": "Функціональною специфікацією програмного продукту називається:",
      "variant_1": [
        " опис поведінки програмного продукту, що визначає функції, які він повинен виконувати",
        "True"
      ],
      "variant_2": [
        "опис мови програмування, обраної для реалізації програмного продукту",
        "False"
      ],
      "variant_3": [
        "опис вимог до архітектури комп’ютера, на якому повинен працювати програмний продукт",
        "False"
      ]
    },
    {
      "test": "Специфікація якості програмного продукту:",
      "variant_1": [
        "визначає функціональні вимоги до програмного продукту",
        "False"
      ],
      "variant_2": [
        " відіграє роль тих орієнтирів, які в значній мірі визначають вибір підходящих альтернатив при реалізації функцій програмного продукт",
        "True"
      ],
      "variant_3": [
        "є документом, що створюється користувачем",
        "False"
      ]
    },
    {
      "test": "Визначення вимог до програмного продукту:",
      "variant_1": [
        "керується розробником",
        "False"
      ],
      "variant_2": [
        " контролюється користувачем",
        "True"
      ],
      "variant_3": [
        "контролюється незалежним експертом",
        "False"
      ]
    },
    {
      "test": "До примітивів якості програмного продукту належать:",
      "variant_1": [
        "універсальність",
        "False"
      ],
      "variant_2": [
        "інтегрованість",
        "False"
      ],
      "variant_3": [
        " завершеність",
        "True"
      ]
    },
    {
      "test": "Функціональна специфікація програмного продукту складається з таких частин:",
      "variant_1": [
        " опису зовнішнього інформаційного середовища, в якому повинен застосовуватися програмний продукт, що розробляється",
        "True"
      ],
      "variant_2": [
        "опису функцій документування, визначених на множині станів середовища  розробки",
        "False"
      ],
      "variant_3": [
        "переліку документів технічної документації",
        "False"
      ]
    },
    {
      "test": "До методів контролю зовнішнього опису програмного продукту належать:",
      "variant_1": [
        "динамічний перегляд",
        "False"
      ],
      "variant_2": [
        " користувацький контроль",
        "True"
      ],
      "variant_3": [
        "контроль незалежного експерта",
        "False"
      ]
    },
    {
      "test": "В процесі розробки програмного продукту використовуються тестові варіанти, які:",
      "variant_1": [
        "завжди забезпечують вичерпне тестування",
        "False"
      ],
      "variant_2": [
        "визначають свій набір розробки програмного забезпечення",
        "False"
      ],
      "variant_3": [
        " визначають свій набір умов для запуску програми",
        "True"
      ]
    },
    {
      "test": "Тестування програмного продукту забезпечує:",
      "variant_1": [
        "виявлення помилок",
        "False"
      ],
      "variant_2": [
        "демонстрацію відсутності дефектів у програмному продукті",
        "False"
      ],
      "variant_3": [
        " демонстрацію реалізації вимог до характеристик програми",
        "True"
      ]
    },
    {
      "test": "Існують такі принципи тестування програмного продукту:",
      "variant_1": [
        " функціональне тестування",
        "True"
      ],
      "variant_2": [
        "оперативне тестування",
        "False"
      ],
      "variant_3": [
        "логічне тестування",
        "False"
      ]
    },
    {
      "test": "При тестуванні програмного продукту за принципом «чорної скрині»",
      "variant_1": [
        " відомі функції програми",
        "True"
      ],
      "variant_2": [
        "відома внутрішня структура програми",
        "False"
      ],
      "variant_3": [
        "досліджуються внутрішні елементи програми та зв’язки між ним",
        "False"
      ]
    },
    {
      "test": "При тестуванні програмного продукту за принципом «білої скрині»:",
      "variant_1": [
        " досліджуються внутрішні елементи програми та зв’язки між ними",
        "True"
      ],
      "variant_2": [
        "відомі функції програми",
        "False"
      ],
      "variant_3": [
        "досліджується робота кожної функції на всій області визначення",
        "False"
      ]
    },
    {
      "test": "При тестуванні програмного продукту за принципом «чорної скрині»:",
      "variant_1": [
        "досліджується внутрішня поведінка програми",
        "False"
      ],
      "variant_2": [
        " розглядаються системні характеристики програм",
        "True"
      ],
      "variant_3": [
        "перевіряється коректність побудови всіх елементів програми і правильність їх взаємодії між собою",
        "False"
      ]
    },
    {
      "test": "При тестуванні програмного продукту за принципом «білої скрині»:",
      "variant_1": [
        " досліджуються внутрішні елементи програми та зв’язки між ними",
        "True"
      ],
      "variant_2": [
        "відомі функції програми",
        "False"
      ],
      "variant_3": [
        "досліджується робота кожної функції на всій області визначення",
        "False"
      ]
    },
    {
      "test": "Тестування «чорної скрині» забезпечує пошук таких категорій помилок у програмному продукті:",
      "variant_1": [
        " некоректних або відсутніх функцій",
        "True"
      ],
      "variant_2": [
        "помилок внутрішніх структур даних",
        "False"
      ],
      "variant_3": [
        "помилок усіх логічних конструкцій програмного коду",
        "False"
      ]
    },
    {
      "test": "В тестових варіантах, що реалізують принцип «білої скрині»",
      "variant_1": [
        "контролюється повнота виконання функціональних вимог до програмного продукту",
        "False"
      ],
      "variant_2": [
        "контролюється збереження цілісності зовнішньої інформації",
        "False"
      ],
      "variant_3": [
        " гарантується перевірка всіх незалежних маршрутів програми",
        "True"
      ]
    },
    {
      "test": "Тестування програмного продукту складається з таких кроків:",
      "variant_1": [
        "тестування окремих процедур і функцій",
        "False"
      ],
      "variant_2": [
        " тестування інтеграції",
        "True"
      ],
      "variant_3": [
        "тестування апаратного забезпечення",
        "False"
      ]
    },
    {
      "test": "Типовими помилками, що визначаються на етапі тестування елементів програмного продукту, є:",
      "variant_1": [
        "втрата даних при проходженні через інтерфейс",
        "False"
      ],
      "variant_2": [
        "несприятливий вплив одного модуля на інший",
        "False"
      ],
      "variant_3": [
        " неправильний або незрозумілий пріоритет арифметичних операцій",
        "True"
      ]
    },
    {
      "test": "Типовими помилками, що визначаються на етапі тестування інтеграції програмного продукту, є",
      "variant_1": [
        "неправильний або незрозумілий пріоритет арифметичних операцій",
        "False"
      ],
      "variant_2": [
        " проблеми при роботі з глобальними структурами даних",
        "True"
      ],
      "variant_3": [
        "некоректна ініціалізація даних",
        "False"
      ]
    },
    {
      "test": "На етапі тестування правильності програмного продукту",
      "variant_1": [
        "здійснюється контроль правильності внутрішніх структур даних",
        "False"
      ],
      "variant_2": [
        " здійснюється перевірка конфігурації програмного продукту",
        "True"
      ],
      "variant_3": [
        "підтримується зборка цільної програмної системи",
        "False"
      ]
    },
    {
      "test": "Для виявлення помилок на етапі тестування правильності програмного продукту використовуються процеси, до складу яких входять",
      "variant_1": [
        "стресове тестування",
        "False"
      ],
      "variant_2": [
        " альфа-тестування",
        "True"
      ],
      "variant_3": [
        "дельта-тестування",
        "False"
      ]
    },
    {
      "test": "До основних типів системних тестів програмного продукту належать:",
      "variant_1": [
        "тестування правильності",
        "False"
      ],
      "variant_2": [
        " тестування безпеки",
        "True"
      ],
      "variant_3": [
        "тестування інтеграції",
        "False"
      ]
    },
    {
      "test": "Розрізняють такі групи методів налагодження програмних продуктів:",
      "variant_1": [
        "функціональні",
        "False"
      ],
      "variant_2": [
        " аналітичні",
        "True"
      ],
      "variant_3": [
        "об’єктивні",
        "False"
      ]
    },
    {
      "test": "До групи документів керування розробкою програмних продуктів належать:",
      "variant_1": [
        " звіти про використання ресурсів в процесі розробки",
        "True"
      ],
      "variant_2": [
        "документація користувача",
        "False"
      ],
      "variant_3": [
        "документація по супроводженню",
        "False"
      ]
    },
    {
      "test": "До групи документів, що входять до складу  програмних продуктів належать:",
      "variant_1": [
        "стандарти",
        "False"
      ],
      "variant_2": [
        "звіти про використання ресурсів в процесі розробки програмних продуктів",
        "False"
      ],
      "variant_3": [
        " документація користувача",
        "True"
      ]
    },
    {
      "test": "Документація користувача використовується при:",
      "variant_1": [
        " інсталяції програмного продукту",
        "True"
      ],
      "variant_2": [
        "модифікації програмного продукту",
        "False"
      ],
      "variant_3": [
        "супроводженні програмного продукту",
        "False"
      ]
    },
    {
      "test": "У відповідності до стандартів документація користувача повинна містити такі розділи:",
      "variant_1": [
        " інструкцію по застосуванню програмного продукту",
        "True"
      ],
      "variant_2": [
        "опис архітектури програмного продукту",
        "False"
      ],
      "variant_3": [
        "тексти модулів на обраній мові програмування",
        "False"
      ]
    },
    {
      "test": "У відповідності до стандартів документація по супроводженню програмного продукту повинна містити такі розділи:",
      "variant_1": [
        "інструкцію по застосуванню програмного продукту",
        "False"
      ],
      "variant_2": [
        "керівництво по інсталяції програмного продукту",
        "False"
      ],
      "variant_3": [
        " опис архітектури програмного продукту",
        "True"
      ]
    },
    {
      "test": "Керування розробкою програмного продукту – це діяльність, направлена на:",
      "variant_1": [
        "виконання планування бюджету розробки та тестування програмних продукті",
        "False"
      ],
      "variant_2": [
        "пошук потенційних замовників програмного продукту",
        "False"
      ],
      "variant_3": [
        " планування та контроль діяльності  колективу розробників з метою забезпечення необхідної якості програмних продуктів",
        "True"
      ]
    },
    {
      "test": "Керування розробкою програмних продуктів складається з таких процесів:",
      "variant_1": [
        "Планування та складання розкладів по впровадженню програмного продукту",
        "False"
      ],
      "variant_2": [
        " Підбір та оцінка персоналу колективу розробників програмного продукту",
        "True"
      ],
      "variant_3": [
        "Організація та проведення навчання користувачів програмного продукту",
        "False"
      ]
    },
    {
      "test": "Найпоширенішими є такі підходи до організації бригад розробників програмного забезпечення:",
      "variant_1": [
        "комбіновані бригади",
        "False"
      ],
      "variant_2": [
        " звичайні бригади",
        "True"
      ],
      "variant_3": [
        "неформальні ліберальні бригади",
        "False"
      ]
    },
    {
      "test": "Розмірно-орієнтовані метрики програмних продуктів базуються на:",
      "variant_1": [
        "UML-оцінках",
        "False"
      ],
      "variant_2": [
        " LOC-оцінках;",
        "True"
      ],
      "variant_3": [
        "XP-оцінках",
        "False"
      ]
    },
    {
      "test": "Функціонально-орієнтовані метрики програмних продуктів базуються на:",
      "variant_1": [
        "FAX-оцінках",
        "False"
      ],
      "variant_2": [
        "LIFO-оцінках",
        "False"
      ],
      "variant_3": [
        " FP-оцінках",
        "True"
      ]
    },
    {
      "test": "До кількісних метрик програмного продукту належать:",
      "variant_1": [
        "питома продуктивність",
        "False"
      ],
      "variant_2": [
        " питома вартість",
        "True"
      ],
      "variant_3": [
        "рентабельність",
        "False"
      ]
    },
    {
      "test": "Для обчислення функціонально-орієнтованих метрик програмного продукту використовуються такі інформаційні характеристики:",
      "variant_1": [
        " кількість зовнішніх запитів",
        "True"
      ],
      "variant_2": [
        "кількість команд програмного коду",
        "False"
      ],
      "variant_3": [
        "кількість розробників програмного продукту",
        "False"
      ]
    },
    {
      "test": "До переваг функціонально-орієнтованих метрик програмних продуктів належать:",
      "variant_1": [
        "отримання результатів на основі суб’єктивних даних",
        "False"
      ],
      "variant_2": [
        " незалежність від мови програмування",
        "True"
      ],
      "variant_3": [
        "використання непрямих вимірів характеристик програмних продуктів",
        "False"
      ]
    },
    {
      "test": "CASE-технології представляють собою:",
      "variant_1": [
        " сукупність методів проектування інформаційних систем",
        "True"
      ],
      "variant_2": [
        "сукупність технічних засобів та оргтехніки",
        "False"
      ],
      "variant_3": [
        "набір інструментальних засобів, які дозволяють  представляти модель предметної області",
        "False"
      ]
    },
    {
      "test": "Тестування – це…",
      "variant_1": [
        " процес виявлення фактів відхилень з вимогами(помилок)",
        "True"
      ],
      "variant_2": [
        "кількість команд програмного коду",
        "False"
      ],
      "variant_3": [
        "процес пошуку, локалізації і виправлення помилок в програмі",
        "False"
      ]
    },
    {
      "test": "Відладка (debug, debugging) – це:",
      "variant_1": [
        "процес виявлення фактів відхилень з вимогами(помилок)",
        "False"
      ],
      "variant_2": [
        "кількість команд програмного коду",
        "False"
      ],
      "variant_3": [
        " процес пошуку, локалізації і виправлення помилок в програмі",
        "True"
      ]
    },
    {
      "test": "Основу системи CORBA становить:",
      "variant_1": [
        "OML – архітектура, як приклад побудови конкретних систем",
        "False"
      ],
      "variant_2": [
        " OMA-архітектура, як базис побудови конкретних прикладних розподілених систем",
        "True"
      ],
      "variant_3": [
        "OBR- компоненти базового рівня побудов",
        "False"
      ]
    },
    {
      "test": "Java-технологія базується на:",
      "variant_1": [
        " Стандартній моделі EJB, призначеній для забезпечення взаємодії різних компонентів за допомогою виклику методу RMI мови Java",
        "True"
      ],
      "variant_2": [
        "Стандартній моделі AVA, призначеній для забезпечення компонентів за допомогою виклику методу RVG мови Java",
        "False"
      ],
      "variant_3": [
        "Стандартній моделі EJB, призначеній для забезпечення взаємодії різних компонентів за допомогою виклику методу RMI мови Java",
        "False"
      ]
    },
    {
      "test": "CASE-технології дозволяють:",
      "variant_1": [
        "в заочній формі моделювати предметну частину розробки",
        "False"
      ],
      "variant_2": [
        " аналізувати модель предметної області на стадіях розробки і супроводження інформаційних систем",
        "True"
      ],
      "variant_3": [
        "здійснювати вибір конфігурації технічних засобів",
        "False"
      ]
    },
    {
      "test": "Репозиторій, як основа CASE-засобу, повинен:",
      "variant_1": [
        " забезпечувати зберігання версій проекту та його окремих компонентів",
        "True"
      ],
      "variant_2": [
        "здійснювати інтерактивне повідомлення користувачів про появу нових версій проекту",
        "False"
      ],
      "variant_3": [
        "здійснювати контроль метаданих на повноту та несперечливість",
        "False"
      ]
    },
    {
      "test": "Діаграммери в складі CASE-засобів забезпечують:",
      "variant_1": [
        "побудову графіків та діаграм на основі даних проекту",
        "False"
      ],
      "variant_2": [
        " створення, переміщення і вирівнювання груп об’єктів, зміну їх розмірів, масштабування",
        "True"
      ],
      "variant_3": [
        "автоматичний контроль частини розробки",
        "False"
      ]
    },
    {
      "test": "Класифікація за типами відображає функціональну орієнтацію CASE-засобів на ті або інші процеси життєвого циклу. За таким принципом виділяють такі групи:",
      "variant_1": [
        " засоби аналізу і проектування",
        "True"
      ],
      "variant_2": [
        "засоби керування проектуванням",
        "False"
      ],
      "variant_3": [
        "засоби програмування",
        "False"
      ]
    },
    {
      "test": "Класифікація CASE-засобів за категоріями визначає ступінь інтегрованості за функціями, що виконуються, і включає:",
      "variant_1": [
        " локальні засоби",
        "True"
      ],
      "variant_2": [
        "глобальні засоби",
        "False"
      ],
      "variant_3": [
        "універсальні засоби",
        "False"
      ]
    },
    {
      "test": "Процес впровадження CASE-засобів включає наступні етапи:",
      "variant_1": [
        " визначення потреб в CASE-засобах",
        "True"
      ],
      "variant_2": [
        "виконання пілотного процесу CASE-засобу",
        "False"
      ],
      "variant_3": [
        "зняття CASE-засобів з експлуатації",
        "False"
      ]
    },
    {
      "test": "Ключем до успішного впровадження CASE-засобів є готовність об’єкту автоматизації, яка включає в себе наступні аспекти:",
      "variant_1": [
        "реклама – масова популяризація властивостей та результатів впровадження CASE-засобів",
        "False"
      ],
      "variant_2": [
        " технологія – розуміння обмеженості  існуючих можливостей і здатність прийняти нову технологію",
        "True"
      ],
      "variant_3": [
        "Розробка – чітка розробка і організованість по відношенню до найбільш важливих етапів і процесів впровадження",
        "False"
      ]
    },
    {
      "test": "В процесі становлення та розвитку програмної інженерії виділено наступні етапи:",
      "variant_1": [
        "виникнення та розвиток мов програмування високого рівня",
        "False"
      ],
      "variant_2": [
        " перехід до індустріальних методів створення програмного забезпечення на основі об’єктно–орієнтованого підходу",
        "True"
      ],
      "variant_3": [
        "виникнення та розвиток нових елементних баз побудови обчислювальної техніки",
        "False"
      ]
    },
    {
      "test": "До основної групи належать наступні процеси ЖЦПЗ:",
      "variant_1": [
        " розробки",
        "True"
      ],
      "variant_2": [
        "документування",
        "False"
      ],
      "variant_3": [
        "навчання",
        "False"
      ]
    },
    {
      "test": "До допоміжної групи належать наступні процеси ЖЦПЗ:",
      "variant_1": [
        "поставки",
        "False"
      ],
      "variant_2": [
        " аудиту",
        "True"
      ],
      "variant_3": [
        "придбання",
        "False"
      ]
    },
    {
      "test": "До  організаційної групи належать наступні процеси ЖЦПЗ:",
      "variant_1": [
        "верифікації",
        "False"
      ],
      "variant_2": [
        " створення інфраструктури",
        "True"
      ],
      "variant_3": [
        "документування",
        "False"
      ]
    },
    {
      "test": "Види моделей життєвого циклу програмного забезпечення:",
      "variant_1": [
        "циліндрична",
        "False"
      ],
      "variant_2": [
        " каскадна",
        "True"
      ],
      "variant_3": [
        "математична",
        "False"
      ]
    },
    {
      "test": "Спрощена версія програмного продукту називається",
      "variant_1": [
        " прототипом",
        "True"
      ],
      "variant_2": [
        "моделлю",
        "False"
      ],
      "variant_3": [
        "шаблоном",
        "False"
      ]
    },
    {
      "test": "Функціональною специфікацією програмного продукту називається",
      "variant_1": [
        "опис алгоритмів, що використовуватимуться програмним продуктом",
        "False"
      ],
      "variant_2": [
        " опис поведінки програмного продукту, що визначає функції, які він повинен виконувати",
        "True"
      ],
      "variant_3": [
        "опис вимог до архітектури комп’ютера, на якому повинен працювати програмний продукт",
        "False"
      ]
    },
    {
      "test": "Є такі внутрішні характеристики якості ПЗ:",
      "variant_1": [
        "коректність, практичність, ефективність, надійність, цілісність, адаптованість, правильність…",
        "False"
      ],
      "variant_2": [
        " зручність супроводження, гнучкість, зручність читання, зрозумілість, можливість повторного використання…",
        "True"
      ],
      "variant_3": [
        "навчання, документування, модернізація, класифікація",
        "False"
      ]
    },
    {
      "test": "Є такі зовнішні характеристики якості ПЗ:",
      "variant_1": [
        " коректність, практичність, ефективність, надійність, цілісність, адаптованість, правильність…",
        "True"
      ],
      "variant_2": [
        "зручність супроводження, гнучкість, зручність читання, зрозумілість, можливість повторного використання…",
        "False"
      ],
      "variant_3": [
        "навчання, документування, модернізація, класифікація",
        "False"
      ]
    },
    {
      "test": "Файл autoexec.bat, який звичайно входить до складу файлів кореневого каталогу в багатьох ОС компанії Microsoft, належить до категорії:",
      "variant_1": [
        "звичайних файлів",
        "False"
      ],
      "variant_2": [
        " системних довідників, що підтримують структуру файлової системи",
        "True"
      ],
      "variant_3": [
        "спеціальних символьних файлів",
        "False"
      ]
    },
    {
      "test": "За допомогою списку прав доступу операційна система забезпечує:",
      "variant_1": [
        "доступ до файлу тільки певного числа процесів",
        "False"
      ],
      "variant_2": [
        " захист файлів від несанкціонованого доступу",
        "True"
      ],
      "variant_3": [
        "кожний процес списком файлів, до яких він може мати доступ",
        "False"
      ]
    },
    {
      "test": "Багато ОС підтримують імена файлів, що полягають із двох частин (ім’я + розширення). Це робиться для того, щоб",
      "variant_1": [
        "спростити запам’ятовування імені файлу",
        "False"
      ],
      "variant_2": [
        " операційна система могла зв’язати це ім’я із прикладною програмою, яка повинна обробляти даний файл",
        "True"
      ],
      "variant_3": [
        "спростити сортування імен файлів при виводі списку файлів у каталозі",
        "False"
      ]
    },
    {
      "test": "Що потрібно зробити, щоб виявити тупик?",
      "variant_1": [
        "порушити 4-у умову виникнення тупиків",
        "False"
      ],
      "variant_2": [
        " перевірити наявність у системі перших трьох умов виникнення тупиків і перевірити виконання четвертої умови",
        "True"
      ],
      "variant_3": [
        "перевірити виконання в системі всіх чотирьох умов виникнення тупиків і порушити умову 4",
        "False"
      ]
    },
    {
      "test": "Як можна вивести систему з тупикової ситуації?",
      "variant_1": [
        "завершити виконання одного із процесів",
        "False"
      ],
      "variant_2": [
        " порушити одну з умов виникнення тупика",
        "True"
      ],
      "variant_3": [
        "організувати в системі засоби відновлення та перезапуску з контрольної відмітки",
        "False"
      ]
    },
    {
      "test": "Як правильно боротися з тупиком, який може виникнути при використанні принтера?",
      "variant_1": [
        "ігнорувати проблему",
        "False"
      ],
      "variant_2": [
        " організувати спулінг (spooling)",
        "True"
      ],
      "variant_3": [
        "відгородити принтер семафором",
        "False"
      ]
    },
    {
      "test": "Коли процес, що перебуває в стані «закінчив виконання», може остаточно покинути систему?",
      "variant_1": [
        "тільки при перезавантаженні операційної системи",
        "False"
      ],
      "variant_2": [
        " по закінченні певного інтервалу часу",
        "True"
      ],
      "variant_3": [
        "після завершення процесу-батька",
        "False"
      ]
    },
    {
      "test": "Які з перерахованих нижче компонентів входять у регістровий контекст процесу?",
      "variant_1": [
        " програмний лічильник процесу",
        "True"
      ],
      "variant_2": [
        "інформація про всі пристрої введення-виводу",
        "False"
      ],
      "variant_3": [
        " уміст регістрів процесора",
        "True"
      ]
    },
    {
      "test": "Що таке мультипрограмна обчислювальна система?",
      "variant_1": [
        "система, у якій реалізований спулінг (spooling)",
        "False"
      ],
      "variant_2": [
        " система, у пам’яті якої одночасно перебуває кілька програм. Коли одна із програм очікує завершення операції введення-виводу, інша програма може виконуватися",
        "True"
      ],
      "variant_3": [
        "система, у пам’яті якої перебуває кілька програм, чиє виконання чергується по закінченні певного проміжку часу",
        "False"
      ]
    },
    {
      "test": "Можливість інтерактивної взаємодії користувача й програми виникає з появою:",
      "variant_1": [
        "систем пакетної обробки",
        "False"
      ],
      "variant_2": [
        " систем поділу часу",
        "True"
      ],
      "variant_3": [
        "мультипрограмних обчислювальних систем",
        "False"
      ]
    },
    {
      "test": "Матриця доступу використовується для:",
      "variant_1": [
        "ідентифікації користувачів",
        "False"
      ],
      "variant_2": [
        " авторизації користувачів",
        "True"
      ],
      "variant_3": [
        "організації аудита системи",
        "False"
      ]
    },
    {
      "test": "Який метод використовується для зберігання елементів матриці доступу в ОС Unix?",
      "variant_1": [
        "переліки можливостей",
        "False"
      ],
      "variant_2": [
        " комбінація списків прав доступу й переліків можливостей",
        "True"
      ],
      "variant_3": [
        "списки прав доступу",
        "False"
      ]
    },
    {
      "test": "Які з перерахованих ситуацій виникають синхронно з роботою процесора:",
      "variant_1": [
        " переривання",
        "True"
      ],
      "variant_2": [
        "виняткові ситуації",
        "False"
      ],
      "variant_3": [
        " програмні переривання",
        "True"
      ]
    },
    {
      "test": "Які з перерахованих функцій базової підсистеми введення-виведення можуть бути делеговані драйверам:",
      "variant_1": [
        "підтримка блокуючих, не блокуючих й асинхронних системних викликів",
        "False"
      ],
      "variant_2": [
        " планування послідовності запитів на виконання операцій уведення-виводу",
        "True"
      ],
      "variant_3": [
        "обробка помилок і переривань, що виникають при операціях уведення-виводу",
        "False"
      ]
    },
    {
      "test": "На яких параметрах може ґрунтуватися довгострокове планування процесів?",
      "variant_1": [
        "на статичних параметрах обчислювальної системи",
        "False"
      ],
      "variant_2": [
        " на статичних параметрах процесів",
        "True"
      ],
      "variant_3": [
        "на динамічних параметрах обчислювальної системи",
        "False"
      ]
    },
    {
      "test": "До якого з перерахованих алгоритмів прагне поведінка алгоритму RR у міру збільшення кванта часу?",
      "variant_1": [
        "SJF",
        "False"
      ],
      "variant_2": [
        " FCFS",
        "True"
      ],
      "variant_3": [
        "гарантоване планування при одному процесі на кожного користувача",
        "False"
      ]
    },
    {
      "test": "Чому запис у таблиці сторінок у схемі віртуальної пам’яті відрізняється від відповідного запису у випадку простої сторінкової організації?",
      "variant_1": [
        "наявністю номера сторінкового кадра",
        "False"
      ],
      "variant_2": [
        " наявністю біта присутності",
        "True"
      ],
      "variant_3": [
        "наявністю атрибутів захисту сторінки",
        "False"
      ]
    },
    {
      "test": "Яка зі схем керування пам’яттю придатна для організації віртуальної пам’яті?",
      "variant_1": [
        "сторінкова",
        "False"
      ],
      "variant_2": [
        " як сегментна, так і сторінкова схеми",
        "True"
      ],
      "variant_3": [
        "сегментна",
        "False"
      ]
    },
    {
      "test": "Схема виділення дискового простору зв’язним списком блоків не знайшла широкого застосування, тому що:",
      "variant_1": [
        "неефективно використовує дисковий простір",
        "False"
      ],
      "variant_2": [
        " вимагає великої кількості звертань до диска при роботі з файлами",
        "True"
      ],
      "variant_3": [
        "страждає від внутрішньої фрагментації",
        "False"
      ]
    },
    {
      "test": "Для чого застосовується журналізація у файлових системах?",
      "variant_1": [
        "для протоколювання дій користувачів",
        "False"
      ],
      "variant_2": [
        " для того, щоб мати можливість скасовувати помилкові зміни даних у файлах користувачів",
        "True"
      ],
      "variant_3": [
        "для підвищення відмовостійкості системи",
        "False"
      ]
    },
    {
      "test": "Скільки вилучених адрес може мати мережний комп’ютер?",
      "variant_1": [
        "тільки один",
        "False"
      ],
      "variant_2": [
        " потенційно довільна кількість",
        "True"
      ],
      "variant_3": [
        "не більш двох",
        "False"
      ]
    },
    {
      "test": "Який рівень еталонної моделі OSI/ISO відповідає за створення контрольних крапок при спілкуванні вилучених процесів?",
      "variant_1": [
        "мережний рівень",
        "False"
      ],
      "variant_2": [
        " рівень сеансу",
        "True"
      ],
      "variant_3": [
        "транспортний рівень",
        "False"
      ]
    },
    {
      "test": "Для розв’язку проблеми інформаційної безпеки необхідно:",
      "variant_1": [
        "застосування законодавчих заходів",
        "False"
      ],
      "variant_2": [
        " комбінація законодавчих, організаційних і програмно-технічних заходів",
        "True"
      ],
      "variant_3": [
        "застосування програмно-технічних заходів",
        "False"
      ]
    },
    {
      "test": "Конфіденційна система забезпечує:",
      "variant_1": [
        "таємність даних користувачів",
        "False"
      ],
      "variant_2": [
        " упевненість у тому, що секретні дані будуть доступні тільки тим користувачам, яким цей доступ дозволений",
        "True"
      ],
      "variant_3": [
        "гарантію того, що авторизованим користувачам завжди буде доступна інформація, яка їм необхідна",
        "False"
      ]
    },
    {
      "test": "Серед несиметричних алгоритмів шифрування найбільш відомий:",
      "variant_1": [
        "Tripledes",
        "False"
      ],
      "variant_2": [
        " RSA",
        "True"
      ],
      "variant_3": [
        "MD5",
        "False"
      ]
    },
    {
      "test": "Внутрішня фрагментація – це:",
      "variant_1": [
        "втрата частини пам’яті, виділеної процесу, але не використовуваної їм",
        "False"
      ],
      "variant_2": [
        " розбивка адресного простору процесу на фрагменти",
        "True"
      ],
      "variant_3": [
        "втрати частини пам’яті в схемі з фіксованими розділами",
        "False"
      ]
    },
    {
      "test": "В чому обумовлена ефективність ієрархічної схеми пам’яті?",
      "variant_1": [
        "швидкістю обміну з оперативною пам’яттю",
        "False"
      ],
      "variant_2": [
        " принципом локалізації обігу",
        "True"
      ],
      "variant_3": [
        "кількістю рівнів в ієрархії",
        "False"
      ]
    },
    {
      "test": "Сегменти – це області пам’яті, призначені для:",
      "variant_1": [
        "зберігання однотипної інформації й організації контролю доступу до неї",
        "False"
      ],
      "variant_2": [
        " зручності відображення логічного адресного простору у фізичне",
        "True"
      ],
      "variant_3": [
        "зберігання окремих процедур програми",
        "False"
      ]
    },
    {
      "test": "Яка категорія засобів зв’язку одержала найбільше поширення в обчислювальних системах?",
      "variant_1": [
        "сигнальні",
        "False"
      ],
      "variant_2": [
        " канальні",
        "True"
      ],
      "variant_3": [
        "поділювана пам’ять",
        "False"
      ]
    },
    {
      "test": "Які процеси можуть обмінюватися інформацією через pipe?",
      "variant_1": [
        "тільки процеси, що мають загального батька, що створив pipe",
        "False"
      ],
      "variant_2": [
        " тільки процес, що створив pipe, і його безпосередній процес-дитина",
        "True"
      ],
      "variant_3": [
        "довільні процеси в системі",
        "False"
      ]
    },
    {
      "test": "Яку стратегію керування пам’яттю може реалізувати алгоритм виштовхування сторінок LRU?",
      "variant_1": [
        "стратегію вибірки, що попереджає, коли крім сторінки, що викликала виняткову ситуацію, на згадку також завантажується кілька сторінок, що оточують її",
        "False"
      ],
      "variant_2": [
        " стратегію розміщення сторінки в пам’яті при наявності списку вільних кадрів",
        "True"
      ],
      "variant_3": [
        "стратегію заміщення",
        "False"
      ]
    },
    {
      "test": "Який результат може мати аналіз біта модифікації, що входить до складу атрибутів сторінки?",
      "variant_1": [
        "необхідність корекції записи про сторінку в таблиці сторінок, оскільки вміст сторінки змінений",
        "False"
      ],
      "variant_2": [
        " зменшення часу обробки page fault`а через те, що копія сторінки вже є на диску",
        "True"
      ],
      "variant_3": [
        "блокування сторінки в пам’яті для того, щоб зберегти зміни вмісту сторінки в недоторканності",
        "False"
      ]
    },
    {
      "test": "Термін «критична секція» ставиться:",
      "variant_1": [
        "до ділянки процесу з найбільшим обсягом обчислювальної роботи",
        "False"
      ],
      "variant_2": [
        " до ділянки процесу, виконання якого разом з іншими процесами може привести до неоднозначних результатів",
        "True"
      ],
      "variant_3": [
        "до ділянки процесу, у якій процес разом з іншими процесами використовує поділювані змінні",
        "False"
      ]
    },
    {
      "test": "Які з умов для організації коректної взаємодії двох процесів за допомогою програмного алгоритму виконані для алгоритму «прапори готовності»?",
      "variant_1": [
        "умова взаємовиключення",
        "False"
      ],
      "variant_2": [
        " умова обмеженого очікування",
        "True"
      ],
      "variant_3": [
        "умова прогресу",
        "False"
      ]
    },
    {
      "test": "Операційні системи сімейства Unix це:",
      "variant_1": [
        "однозадачні системи",
        "False"
      ],
      "variant_2": [
        " багатозадачні та багатокористувацькі системи",
        "True"
      ],
      "variant_3": [
        "багатозадачні однокористувацькі системи",
        "False"
      ]
    },
    {
      "test": "Інженери якої фірми розробили перший варіант Unix?",
      "variant_1": [
        "Microsoft",
        "False"
      ],
      "variant_2": [
        " AT&T",
        "True"
      ],
      "variant_3": [
        "IBM",
        "False"
      ]
    },
    {
      "test": "Якому стандарту має відповідати ОС сiмейства Unix?",
      "variant_1": [
        "POSIX",
        "False"
      ],
      "variant_2": [
        " ISO/IEC",
        "True"
      ],
      "variant_3": [
        "WEB",
        "False"
      ]
    },
    {
      "test": "Яке з нижче наведених понять є фундаментальним для Unix?",
      "variant_1": [
        "вікно",
        "False"
      ],
      "variant_2": [
        " файл",
        "True"
      ],
      "variant_3": [
        "піктограма",
        "False"
      ]
    },
    {
      "test": "Яка мова програмування найчастіше використовується для розробки Unix?",
      "variant_1": [
        " C",
        "True"
      ],
      "variant_2": [
        "C++",
        "False"
      ],
      "variant_3": [
        "Basic",
        "False"
      ]
    },
    {
      "test": "Яким є традиційний спосіб взаємодії користувача з Unix?",
      "variant_1": [
        "графічний",
        "False"
      ],
      "variant_2": [
        " текстовий інтерфейс на основі використання командних мов",
        "True"
      ],
      "variant_3": [
        "звуковий",
        "False"
      ]
    },
    {
      "test": "Яке ім’я у суперкористувача в Unix?",
      "variant_1": [
        "admin",
        "False"
      ],
      "variant_2": [
        " root",
        "True"
      ],
      "variant_3": [
        "адміністратор",
        "False"
      ]
    },
    {
      "test": "Як називається програма, що виконується в даний момент?",
      "variant_1": [
        "файл",
        "False"
      ],
      "variant_2": [
        " процес",
        "True"
      ],
      "variant_3": [
        "вікно",
        "False"
      ]
    },
    {
      "test": "З якою ліцензією розповсюджується ОС Linux?",
      "variant_1": [
        "EULA",
        "False"
      ],
      "variant_2": [
        " GPL",
        "True"
      ],
      "variant_3": [
        "BSD",
        "False"
      ]
    },
    {
      "test": "Як називається графічна підсистема, що використовується в Linux?",
      "variant_1": [
        "MS Windows",
        "False"
      ],
      "variant_2": [
        " X Window",
        "True"
      ],
      "variant_3": [
        "Mac OS X",
        "False"
      ]
    },
    {
      "test": "Яка з команд наведених нижче використовується для отримання довідки по будь-якій команді системи Windows:",
      "variant_1": [
        "seek",
        "False"
      ],
      "variant_2": [
        " help",
        "True"
      ],
      "variant_3": [
        "explorer",
        "False"
      ]
    },
    {
      "test": "Як називається система, що надає користувачам i процесам ресурси довгострокової пам’яті?",
      "variant_1": [
        "система пам’яті",
        "False"
      ],
      "variant_2": [
        " зовнішня пам’ять",
        "True"
      ],
      "variant_3": [
        "віртуальна пам’ять",
        "False"
      ]
    },
    {
      "test": "Як називається структура, що зберігає всю необхідну інформацію про файл?",
      "variant_1": [
        "каталог",
        "False"
      ],
      "variant_2": [
        " індексний дескриптор",
        "True"
      ],
      "variant_3": [
        "папка",
        "False"
      ]
    },
    {
      "test": "Скільки імен може мати файл в Unix та Windows?",
      "variant_1": [
        "безліч",
        "False"
      ],
      "variant_2": [
        " одне",
        "True"
      ],
      "variant_3": [
        "файли в Unix не мають імен, лише номери",
        "False"
      ]
    },
    {
      "test": "Які символи не можуть входити в імена файлів?",
      "variant_1": [
        "обмеження на символи в імені файлу відсутні",
        "False"
      ],
      "variant_2": [
        " символ з кодом 0 та /",
        "True"
      ],
      "variant_3": [
        "ім’я файлу може складатись лише з алфавітно-цифрових символів",
        "False"
      ]
    },
    {
      "test": "Як називається структура, що містить набір файлів?",
      "variant_1": [
        "сховище файлів",
        "False"
      ],
      "variant_2": [
        " каталог",
        "True"
      ],
      "variant_3": [
        "файл файлів",
        "False"
      ]
    },
    {
      "test": "Як називається каталог найвищого рівня?",
      "variant_1": [
        "С:",
        "False"
      ],
      "variant_2": [
        " кореневим",
        "True"
      ],
      "variant_3": [
        "головним",
        "False"
      ]
    },
    {
      "test": "Як називається список імен вкладених каталогів, що починається з кореневого i закінчується ім’ям файлу?",
      "variant_1": [
        "каталогом",
        "False"
      ],
      "variant_2": [
        " повним ім’ям файлу",
        "True"
      ],
      "variant_3": [
        "суперiм’ям",
        "False"
      ]
    },
    {
      "test": "Яка команда використовується для переходу в інший каталог?",
      "variant_1": [
        "dir",
        "False"
      ],
      "variant_2": [
        " cd",
        "True"
      ],
      "variant_3": [
        "mc",
        "False"
      ]
    },
    {
      "test": "Який псевдонiм має власний каталог користувача?",
      "variant_1": [
        "*",
        "False"
      ],
      "variant_2": [
        " ~",
        "True"
      ],
      "variant_3": [
        "H",
        "False"
      ]
    },
    {
      "test": "В якому каталозі розміщуються каталоги користувачів?",
      "variant_1": [
        "C:\\WINDOWS\\Temp\\",
        "False"
      ],
      "variant_2": [
        " /home",
        "True"
      ],
      "variant_3": [
        "/UserDirs",
        "False"
      ]
    },
    {
      "test": "Що з нижче наведеного є файлами в Unix?",
      "variant_1": [
        "гнiзда",
        "False"
      ],
      "variant_2": [
        " іменованi канали",
        "True"
      ],
      "variant_3": [
        "вiкно програми",
        "False"
      ]
    },
    {
      "test": "На які типи поділяються фізичні пристрої в Unix?",
      "variant_1": [
        "графічні",
        "False"
      ],
      "variant_2": [
        " символьні",
        "True"
      ],
      "variant_3": [
        "мобільні",
        "False"
      ]
    },
    {
      "test": "Яка команда використовується для створення твердих та символічних посилань?",
      "variant_1": [
        "link",
        "False"
      ],
      "variant_2": [
        " ln",
        "True"
      ],
      "variant_3": [
        "create_link",
        "False"
      ]
    },
    {
      "test": "Як називається кореневий каталог файлової системи Linux?",
      "variant_1": [
        "C",
        "False"
      ],
      "variant_2": [
        " /",
        "True"
      ],
      "variant_3": [
        "/sys",
        "False"
      ]
    },
    {
      "test": "На які категорії розділяються користувачі відносно файлів?",
      "variant_1": [
        "розділення відсутнє",
        "False"
      ],
      "variant_2": [
        " власник, група, iнші",
        "True"
      ],
      "variant_3": [
        "власник, адміністратор",
        "False"
      ]
    },
    {
      "test": "Які дії над файлами визначають права доступу до файлів?",
      "variant_1": [
        "видаляти, перейменовувати",
        "False"
      ],
      "variant_2": [
        " читати, писати, виконувати",
        "True"
      ],
      "variant_3": [
        "надсилати по e-mail",
        "False"
      ]
    },
    {
      "test": "Яка команда застосовується для зміни прав доступу до файлів в Linux?",
      "variant_1": [
        "chown",
        "False"
      ],
      "variant_2": [
        " chmod",
        "True"
      ],
      "variant_3": [
        "changeMode",
        "False"
      ]
    },
    {
      "test": "Яка команда застосовується для копіювання файлів в MS-DOS?",
      "variant_1": [
        "cp",
        "False"
      ],
      "variant_2": [
        " copy",
        "True"
      ],
      "variant_3": [
        "move",
        "False"
      ]
    },
    {
      "test": "Яка команда застосовується для підключення файлових систем в загальне дерево каталогів?",
      "variant_1": [
        "mkfs",
        "False"
      ],
      "variant_2": [
        " mount",
        "True"
      ],
      "variant_3": [
        "bind",
        "False"
      ]
    },
    {
      "test": "Як називається сукупність коду й даних, що завантажені в пам’ять комп’ютера?",
      "variant_1": [
        "програма",
        "False"
      ],
      "variant_2": [
        " процес",
        "True"
      ],
      "variant_3": [
        "файл",
        "False"
      ]
    },
    {
      "test": "Як називається процес, що вже не виконується й не займає пам’ять, але про який є запис в таблиці процесів?",
      "variant_1": [
        "вампір",
        "False"
      ],
      "variant_2": [
        " зомбі",
        "True"
      ],
      "variant_3": [
        "відьмак",
        "False"
      ]
    },
    {
      "test": "Яка команда показує список процесів, що виконуються?",
      "variant_1": [
        "proclist",
        "False"
      ],
      "variant_2": [
        " ps",
        "True"
      ],
      "variant_3": [
        "ls",
        "False"
      ]
    },
    {
      "test": "Яким системним викликом в Unix виконується запуск процесів?",
      "variant_1": [
        "exit",
        "False"
      ],
      "variant_2": [
        " exec",
        "True"
      ],
      "variant_3": [
        "execute",
        "False"
      ]
    },
    {
      "test": "Як називається коротке повідомлення, що посилається процесом чи системою іншому процесу?",
      "variant_1": [
        "лист",
        "False"
      ],
      "variant_2": [
        " сигнал",
        "True"
      ],
      "variant_3": [
        "повідомлення",
        "False"
      ]
    },
    {
      "test": "На якому стандарті базується графічне середовище Linux?",
      "variant_1": [
        "MS Windows",
        "False"
      ],
      "variant_2": [
        " X Window System",
        "True"
      ],
      "variant_3": [
        "OS X",
        "False"
      ]
    },
    {
      "test": "Яку модель застосовує система X Window System?",
      "variant_1": [
        "мейнфрейм",
        "False"
      ],
      "variant_2": [
        " клієнт-сервер",
        "True"
      ],
      "variant_3": [
        "CORBA",
        "False"
      ]
    },
    {
      "test": "Що з нижченаведеного не є віконним менеджером X Window System?",
      "variant_1": [
        "GNOME",
        "False"
      ],
      "variant_2": [
        " MS Windows",
        "True"
      ],
      "variant_3": [
        "KDE",
        "False"
      ]
    },
    {
      "test": "Що або хто створює вбудовані змінні оболонки?",
      "variant_1": [
        "операційна система",
        "False"
      ],
      "variant_2": [
        " користувач",
        "True"
      ],
      "variant_3": [
        "скріпт",
        "False"
      ]
    },
    {
      "test": "Як називається міжмережевий протокол, що забезпечує транспортування без додаткової обробки даних з однієї машини на іншу?",
      "variant_1": [
        "TCP",
        "False"
      ],
      "variant_2": [
        " IP",
        "True"
      ],
      "variant_3": [
        "ARP",
        "False"
      ]
    },
    {
      "test": "Як називається міжмережевий протокол керування повідомленнями?",
      "variant_1": [
        "ICMP",
        "False"
      ],
      "variant_2": [
        " IP",
        "True"
      ],
      "variant_3": [
        "TCP",
        "False"
      ]
    },
    {
      "test": "Як називається протокол перетворення адрес, що виконує трансляцію логічних мережних адрес в апаратні?",
      "variant_1": [
        "IP",
        "False"
      ],
      "variant_2": [
        " ARP",
        "True"
      ],
      "variant_3": [
        "TCP",
        "False"
      ]
    },
    {
      "test": "Як називається протокол керування передачею?",
      "variant_1": [
        "UDP",
        "False"
      ],
      "variant_2": [
        " TCP",
        "True"
      ],
      "variant_3": [
        "ARP",
        "False"
      ]
    },
    {
      "test": "Як називається апаратна адреса вузла мережі?",
      "variant_1": [
        "MAC-адреса",
        "False"
      ],
      "variant_2": [
        " IP-адреса",
        "True"
      ],
      "variant_3": [
        "e-mail",
        "False"
      ]
    },
    {
      "test": "Як називається вузол у мережі TCP/IP?",
      "variant_1": [
        "TCP-адреса",
        "False"
      ],
      "variant_2": [
        " IP-адреса",
        "True"
      ],
      "variant_3": [
        "MAC-адреса",
        "False"
      ]
    },
    {
      "test": "Який додатковий елемент додають протоколи до IP-адреси?",
      "variant_1": [
        "канал",
        "False"
      ],
      "variant_2": [
        " порт",
        "True"
      ],
      "variant_3": [
        "пароль",
        "False"
      ]
    },
    {
      "test": "В С# визначення цифрового символу виконується методом класу Char:",
      "variant_1": [
        "IsDigit()",
        "True"
      ],
      "variant_2": [
        "IsNumber()",
        "False"
      ],
      "variant_3": [
        "IsValue()",
        "False"
      ]
    },
    {
      "test": "В System.Windows.Forms дозвіл на використання клавіші BackSpace в тестовому полі TextBox надається при позитивному результаті порівняння в обробнику події KeyPress",
      "variant_1": [
        "e.KeyChar == (char)Keys.Back",
        "True"
      ],
      "variant_2": [
        "e.KeyChar == Keys.Back",
        "False"
      ],
      "variant_3": [
        "e.KeyChar == (char)Keys.Return",
        "False"
      ]
    },
    {
      "test": "В System.Windows.Forms прив’язка списку ComboBox до поля таблиця БД забезпечується вибором у його властивості DataSource екземпляру класу",
      "variant_1": [
        "DataDable",
        "False"
      ],
      "variant_2": [
        "DataColumn",
        "False"
      ],
      "variant_3": [
        "BindingSource",
        "True"
      ]
    },
    {
      "test": "В System.Windows.Forms елементи, що відображаються списку ComboBox, прив’язаного до поля таблиця БД, визначаються його властивістю",
      "variant_1": [
        "DataSource",
        "False"
      ],
      "variant_2": [
        "DisplayMember",
        "True"
      ],
      "variant_3": [
        "ValueMember",
        "False"
      ]
    },
    {
      "test": "В System.Windows.Forms елементи списку ComboBox, прив’язаного до поля таблиця БД, визначаються за значенням ключового поля, що зберігається у його властивості",
      "variant_1": [
        "DisplayMember",
        "False"
      ],
      "variant_2": [
        "ValueKey",
        "False"
      ],
      "variant_3": [
        "ValueMember",
        "True"
      ]
    },
    {
      "test": "В System.Windows.Forms значення ключового поля таблиці БД, обраного в прив’язаному списку ComboBox, міститься у його властивості",
      "variant_1": [
        "SelectedValue",
        "True"
      ],
      "variant_2": [
        "SelectedMember",
        "False"
      ],
      "variant_3": [
        "SelectedItem",
        "False"
      ]
    }
]